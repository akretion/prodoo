{"_id":"lru-cache","_rev":"270-7b29df6602e85e28b6bc67e3b2b315d6","name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","dist-tags":{"latest":"7.14.0","legacy":"4.1.5","v7.2-backport":"7.2.3","v7.1-backport":"7.1.3","v7.0-backport":"7.0.4","v7.3-backport":"7.3.3","v7.7-backport":"7.7.4","v7.6-backport":"7.6.1","v7.5-backport":"7.5.2","v7.4-backport":"7.4.5"},"versions":{"1.0.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.0.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"node lib/lru-cache.js"},"main":"lib/lru-cache","_id":"lru-cache@1.0.1","engines":{"node":"*"},"_nodeSupported":true,"_npmVersion":"0.2.7-2","_nodeVersion":"v0.3.1-pre","dist":{"tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.0.1.tgz","shasum":"fbfcd2d6e2d8f4519be9826bca3cb70900ffcd4b","integrity":"sha512-z0Jr4NF2G+dPi1P98wARYOq0b0CTI2izu3gX2ZkndnKim4ZE4e0qIiI+6k48KF4FueBXakPqF0R3y9xJEFE/VA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC2D0SqSc/RzFRCr3a7c3w3VeQ6QuEDXgh22iCmEaMlzAIgYdlYMbZCkYpkNXoknF4I1EzkA3VuEkpdogDaP8z1z8Q="}]},"directories":{}},"1.0.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.0.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"node lib/lru-cache.js"},"main":"lib/lru-cache","_id":"lru-cache@1.0.2","engines":{"node":"*"},"_nodeSupported":true,"_npmVersion":"0.2.7-3","_nodeVersion":"v0.3.1-pre","dist":{"tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.0.2.tgz","shasum":"04deae53134b6583567c849d868a2d10d5991bfd","integrity":"sha512-xrRAw9qb4GaHCm0QyJbldrYBbSYgL34hk2FFXgFOsrO0R7lnSVjQXVfDKF4RmlpkHU87JG58JZDRAjteN9gEvA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD4h++jdoYHafR5Ju510yIpwFjPlcDTUd3tCEj2xnqxzAIhAJGD0iWgJzYPZvl3Zd++9KVtMrfLnaQkjrODhu6wXc7J"}]},"directories":{}},"1.0.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.0.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"node lib/lru-cache.js"},"main":"lib/lru-cache","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"_npmJsonOpts":{"file":"/Users/isaacs/.npm/lru-cache/1.0.3/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"lru-cache@1.0.3","dependencies":{},"devDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.0.15","_nodeVersion":"v0.5.2-pre","_defaultsLoaded":true,"dist":{"shasum":"ef2ba05194250bd4781dbe57b6064d7320e58b73","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.0.3.tgz","integrity":"sha512-kAySFADtNDZ41WmCGqFBlQ90ZztEfQ+k1UDFXAHxjrN0QBPmeQYpDL0/3s/BJwaOEqXtue9OLBl0o3GHDvRJXA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCkk2dCQ3PQyWe3Twh/YPcept9je4nP1uDPHaMvjJxefAIgGq3Sk4Rt+3PJ5zR6tUUgOHcV1fBoXLueTpOT7Q6pfXs="}]},"directories":{}},"1.0.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.0.4","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"node lib/lru-cache.js"},"main":"lib/lru-cache","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"licenses":[{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"}],"_npmJsonOpts":{"file":"/Users/isaacs/.npm/lru-cache/1.0.4/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"lru-cache@1.0.4","dependencies":{},"devDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.0.22","_nodeVersion":"v0.4.10-pre","_defaultsLoaded":true,"dist":{"shasum":"dc2af9b3022fb7e17630ed7bdf6a1839b7b70291","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.0.4.tgz","integrity":"sha512-wWgerry4u8LGwwavm+dw+1WiqFvC4DiifUf05ASmOGQz0OJh3UYIPwzVD35YyjXQtKTYpnPGFAgBAZL3+fQJvQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD4ciymscQtBjqEk554DFJd+hJhlKRbyM9MMA8/SDjCMgIgHX3u9pimeTVZuv3ZxO6E1E9UiNmoJEyscoInP4VJa8w="}]},"directories":{}},"1.0.5":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.0.5","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"0.1"},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_id":"lru-cache@1.0.5","dependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.6-pre","_defaultsLoaded":true,"dist":{"shasum":"62815a3bcb609c1c086e78e4c6a1c4c025267551","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.0.5.tgz","integrity":"sha512-78LsxOtsCtZe6QOYdrBnSlI8j0r7bal9Les5ZQH0njXtAuKLQpwd2UOTe0+r0CzKsDeH/ujYXJNCswYj6Mq9Tg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDYz9dg7SJNiaoWnoWUJUSNu7J4nV19yqBrAQwfLSQTiwIhAKjG/+U3OT/PCRZPyKXPZ8i2kzorgNoI+rVi0Ds5/kPG"}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"1.0.6":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.0.6","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"0"},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_id":"lru-cache@1.0.6","dependencies":{},"optionalDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.1.12","_nodeVersion":"v0.7.7-pre","_defaultsLoaded":true,"dist":{"shasum":"aa50f97047422ac72543bda177a9c9d018d98452","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.0.6.tgz","integrity":"sha512-mM3c2io8llIGu/6WuMhLl5Qu9Flt5io8Epuqk+iIbKwyUwDQI6FdcCDxjAhhxYqgi0U17G89chu/Va1gbKhJbw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEA9zTsAcceBCmT6vtCTkhpfkxaUX7+gOZm1o//6tmKoAiEAjw0b1LxntWDMraV0GTqxRsanMS+z763zRggD67EudSU="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"1.1.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.1.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_id":"lru-cache@1.1.0","contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"}],"dependencies":{},"optionalDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.1.16","_nodeVersion":"v0.7.8-pre","_defaultsLoaded":true,"dist":{"shasum":"8d4a68dc0ab1cd5a2f39352478c495e9dd33cb61","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.1.0.tgz","integrity":"sha512-CPLaY1EghHiGwL1adHzxAjIXaMWR2lk0g4bfvVsmPXl6M28n2uQdY65F69O0FJw5iQ6sfuTohqelGAjZa/coNQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDLBVk3cL2uca7Uwj8exs+TC0VexKJ3RLSVDXhhM/RTtgIgAnWEoZFtQVSzafQtL9Q4FsiiOzcwWGL2tZB6GGBOS2s="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"1.1.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"1.1.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"}],"_id":"lru-cache@1.1.1","dist":{"shasum":"d6f24f75c28c9ec1239ca206952689696ec11e62","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-1.1.1.tgz","integrity":"sha512-Hjrglk5sZedTAMJHe1KrK833YyYVUfiZgsmVQ1YplQwa3xQUrE/wtmhZ0Mc3GDvmpgtiSw1/Z05NAsOx/IpYeQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDJj+AI6kKhMrq6bX7FyGFO2Ukp7QmPOvMK86XOB3IgggIgDP7CCr+QzJn4zwORX7LZGUuwF9zSpY2JWWUnJZHQKLw="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.0.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.0.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"}],"_id":"lru-cache@2.0.0","dist":{"shasum":"0fc80ed1e8276dcce18a865bce8a56ba30b81ecf","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.0.0.tgz","integrity":"sha512-LGKBUSgkwjNCPpZZa2CU3bVhqSYNMmBktH12A/ITj3wvi+DmBbZCL+ovIwEnoaC04J179aU308+bmQqpKHTslg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIC54oA9GBSbrbsI73R2eHcQ7zJalCe6lx0eAGTdf/ehNAiB0a3aNYc0fE2yAhKaDYY//UmBiK68R1MRWpHMeF8G73w=="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.0.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.0.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"}],"_id":"lru-cache@2.0.1","dist":{"shasum":"6feae28419f7fc358a063a5b188d52d15538006a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.0.1.tgz","integrity":"sha512-CeQC0bWCsrWvvnYEX+gpMlubqaF00VmVsl/lL2n+m0RQLtZ/2Hd8zypbKjF70UPY7B+1F9bjdyjteM1h8VeJsg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDovWuhx3BOHs/+Gy8vhZUrMR+FF6/xKRe1uMYaGwpo6gIgfjnc0VED1oIIe/NHuSArq+lgOjctnaTdQ+U90YAYCZU="}]},"_npmVersion":"1.1.48","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.0.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.0.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.0.2","dist":{"shasum":"c7e26bb69eabb8f6ee8242b3a569f5af7ee2fd3b","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.0.2.tgz","integrity":"sha512-NUy98YbQ5PyHRA+erk4IUiIiFfxgMpQWoaO+WZZU7enoEHqSOoasRRvHjlIXjwW6MUQ1B3qEsU7+1yP4DnbdPw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICV05Q4t4PCh0m07tSOwg1cugbbArGm1O8MiHZYWIYilAiEAlO9x3TJ/z0vpazHXFnujVVdhG8i3bgkVX0oAxBv/3zo="}]},"_npmVersion":"1.1.59","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.0.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.0.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.0.3","dist":{"shasum":"dc18834f4a2e2b45faab6170b69b74741ef3871a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.0.3.tgz","integrity":"sha512-k4cXk0ZciKMXzC3kJ1eq3WpQGTT0LidL6L/ocJLEgSibwZquCTrj2SWpD8r3ZuCsPo/nrA94NHBhn8Db7CX9Fw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBH8L+hlTE/rlkkWCmBOkgl+3u9btOeN/y5eHRs9BGBeAiBlfVyIQN3keXdG/mFc/LgqU39LHSPxxV0Ftc7ffMENUg=="}]},"_npmVersion":"1.1.61","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.0.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.0.4","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.0.4","dist":{"shasum":"b8b61ae09848385ec6768760e39c123e7e39568a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.0.4.tgz","integrity":"sha512-p6+W5xtxxT2y2bKbZuGSz3Rr2mkq+Mq4kXt7FRntJNTeu0BkaNN9AwGvygEz3G90d08JwfgLK9Ho6jbh0SwPQg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEL9Y+LooAaCbhBssVElMvPfPWSaS37j1Or08pMpHr88AiAVX9NBtsYTYShwiX7O1E2g5pPeoTsN6r5y44lD+r6iRQ=="}]},"_npmVersion":"1.1.61","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.1.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.1.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.1.0","dist":{"shasum":"ea1baa0fc9146c586aee06bd2fc547ab480e2e3c","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.1.0.tgz","integrity":"sha512-hOpKYIlkW9UbrqQoyaAMJQamdDQqPLL2lA0y+7Oz3bFb69nWJEjrtZ414dqeUsBNaDgbQlHU+yUA91Bf7eZiuw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHdWT3fp1A3s5kR+ctNHw6DOpAlXz3r2C3BxUrUHIo7/AiB+0v98hFF3GLQkI2PbXsxwIOPGjlzM3N+DJKJ/QRwj5A=="}]},"_npmVersion":"1.1.63","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.2.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.2.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.2.0","dist":{"shasum":"ec2bba603f4c5bb3e7a1bf62ce1c1dbc1d474e08","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.2.0.tgz","integrity":"sha512-nnQiy1lsNj5xmeoe48piKcv2xWdL6KXxJeN3aobdSH939OMTK/qXRkuVSVAM59nS2KMPBeuqx5GD+e8JbZwPdQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICBwvASSJ3FVqG84xZ1pcDCAxCjxZveUKgbILHADeVVeAiEAqNpfho5vFAZkj2mwGBRKpFOM+uJNVtDFSHc0qVK/pxs="}]},"_npmVersion":"1.1.66","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.2.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.2.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.2.1","dist":{"shasum":"dcc1de19e79242874a0e883d09bb1ce5c2bb58f4","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.2.1.tgz","integrity":"sha512-sfqhHkcOe7AbbzwvLSHnpHs/VzISX1qy10leIBYZ6cD5MqHIaIm4qIJeQQiq4DmfY/aYmfMOl4iD1R+xTrREGA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCaFzIvoKb4I0C4fwH5wUCtGzkKqUPRHPDDj+0czwwb9gIhAMmkhMn6BVlmSSEK9w8ISqsUsElSf8OTrMSgf1VIQHLo"}]},"_npmVersion":"1.1.66","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.2.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.2.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.2.2","dist":{"shasum":"62b95a10cc7f8d85f3737506fe82cdcf3fa04d4b","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.2.2.tgz","integrity":"sha512-L0bzqz8cxAiIBO0Fxnp/LJSGvq9uaIBVyj3TSbHYQx2iswlaammlWVBSIaxqGTOKZjaNu8h6VgyrlOHYyl53iw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCmaamflzCtiIGoBGVP8iK4t4EAv1DZTp8FnUlMjY9yKgIgVB2M+O2px+3qrf5SK1lLOBVA2NlcuO7LTP/VU5kgiNE="}]},"_from":".","_npmVersion":"1.2.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.2.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.2.4","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.2.4","dist":{"shasum":"6c658619becf14031d0d0b594b16042ce4dc063d","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.2.4.tgz","integrity":"sha512-Q5pAgXs+WEAfoEdw2qKQhNFFhMoFMTYqRVKKUMnzuiR7oKFHS7fWo848cPcTKw+4j/IdN17NyzdhVKgabFV0EA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDjb98+9F53NuXk0XGrQ6wslAIrO4ewfBFG+HE2AStQYwIhAKWv9IEDPa7Yu2dW6aUs0xNBfP0lOgc9v9fSIWDVmx+X"}]},"_from":".","_npmVersion":"1.2.15","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.3.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.3.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"_id":"lru-cache@2.3.0","dist":{"shasum":"1cee12d5a9f28ed1ee37e9c332b8888e6b85412a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.3.0.tgz","integrity":"sha512-XyBCYL0kTZLNIFj48mAUe1Q0PTLsOlH4ck3YhHM+Z2Aai8aELn6bqc+Ieh4gpaN3diduq5A06WaNz2Qq+8RuMA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDzYKhqrQY5FvudDAFzZFkkREaczzne/pvqCiR1aEHFEwIgPARlLs3p+qlb0EGq3Xl5GnKW1sjxE+Jzu0rdTITH+wg="}]},"_from":".","_npmVersion":"1.2.15","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.3.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.3.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"contributors":[{"name":"Isaac Z. Schlueter","email":"i@izs.me"},{"name":"Carlos Brito Lage","email":"carlos@carloslage.net"},{"name":"Marko Mikulicic","email":"marko.mikulicic@isti.cnr.it"},{"name":"Trent Mick","email":"trentm@gmail.com"},{"name":"Kevin O'Hara","email":"kevinohara80@gmail.com"},{"name":"Marco Rogers","email":"marco.rogers@gmail.com"},{"name":"Jesse Dailey","email":"jesse.dailey@gmail.com"}],"bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"_id":"lru-cache@2.3.1","dist":{"shasum":"b3adf6b3d856e954e2c390e6cef22081245a53d6","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.3.1.tgz","integrity":"sha512-EjtmtXFUu+wXm6PW3T6RT1ekQUxobC7B5TDCU0CS0212wzpwKiXs6vLun+JI+OoWmmliWdYqnrpjrlK7W3ELdQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAMiFENBV55+BqRn+/0SxZC0y9lQogg5W7VTJ712cCl7AiEAqDTLIVU9WPellZLj54XYJveT0SN8Z6GhVokUaqkkz0o="}]},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.5.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.5.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache","_id":"lru-cache@2.5.0","dist":{"shasum":"d82388ae9c960becbea0c73bb9eb79b6c6ce9aeb","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.5.0.tgz","integrity":"sha512-dVmQmXPBlTgFw77hm60ud//l2bCuDKkqC2on1EBoM7s9Urm9IQDrnujwZ93NFnAq0dVZ0HBXTS7PwEG+YE7+EQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAhGLHLU59I847Wmq5J67+L9v4Wq45IrNhf1uyGbqtBvAiAkAJAzdycYP4v21v2IZ/sNd0+Xd+Tgjfve5DuHbDYwTA=="}]},"_from":".","_npmVersion":"1.3.15","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.5.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.5.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"gitHead":"355fb2d7acd89f08d400345ce2ca8cd27b672095","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache","_id":"lru-cache@2.5.1","_shasum":"60b81048343cd901d529c97a7284810b4aa2ca03","_from":".","_npmVersion":"2.7.6","_nodeVersion":"1.4.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"dist":{"shasum":"60b81048343cd901d529c97a7284810b4aa2ca03","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.5.1.tgz","integrity":"sha512-FIGZXhZfWjFRTSYBtulC929NjRAi+0m0wcUvIFLB+RtEEccMMV4cqGaHGwREqmus/WA/qB60W8tR4NaUz/ldAw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDHnm+1PXiDgv/SvAOLzLyVPehT3m228cgN5WNja/mFsgIhAK/MlKmvSQEOINcPDanfGkzb3ts558d0M7xqZg2+k8zb"}]},"directories":{}},"2.5.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.5.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^0.7.1","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"gitHead":"ec01cc48ac06ee07b2b56a219d5aa931f899b21b","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache","_id":"lru-cache@2.5.2","_shasum":"1fddad938aae1263ce138680be1b3f591c0ab41c","_from":".","_npmVersion":"2.7.6","_nodeVersion":"1.4.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"dist":{"shasum":"1fddad938aae1263ce138680be1b3f591c0ab41c","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.5.2.tgz","integrity":"sha512-wyqfj+623mgqv+bpjTdivSoC/LtY9oOrmKz2Cke0NZcgYW9Kce/qWjd9e5PDYf8wuiKfVeo8VnyOSSyeRiUsLw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDxWC75EwtFcmqZAupus4uQbuLe9EuOvitashKCNS1/KAIgE0rkvc6y30fWpciclRXBoW5NgCkPRseqQhLVOeyhRyE="}]},"directories":{}},"2.6.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.6.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^0.7.1","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"gitHead":"1763ce34f26d9d011191e7f1b3e39345d9c0851d","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.6.0","_shasum":"a26389f2e49a5586f42f3f00a430d4e8798b287f","_from":".","_npmVersion":"2.8.1","_nodeVersion":"1.4.2","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"a26389f2e49a5586f42f3f00a430d4e8798b287f","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.0.tgz","integrity":"sha512-h0VpjAsJSq0QW3FSLM0sX4B25UIt6H9rY1Mir/1tfhdVsCX7ynWWO6PO4TDwooR5cpODkPTPy45De+UQQqBY3g==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA6Eu+RDiTjy+vrG7pDs4r16d2pbbO9mYYKw9AE5XgjoAiBVeNCb47m71Hi/MP0yZjjTtoyW5O3LNMpJL/sXm0Rbfg=="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.6.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.6.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^0.7.1","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"gitHead":"ff3dfd40e437fa619f09610f45d1ac523bbf27c9","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.6.1","_shasum":"9933eff15453fae1d27096365143c724e85c6cbd","_from":".","_npmVersion":"2.8.1","_nodeVersion":"1.4.2","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"9933eff15453fae1d27096365143c724e85c6cbd","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.1.tgz","integrity":"sha512-Iax0mM/BEBb16fyjFfC/Iqn2Ef39u4nlSjN6bLw7X9VzsYnjvBKiOP6JxmQtoFSTOdkAIoVtgZ4tSykAAXRMzg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGkJE49grf5/bN39t8xLLOHH6J7rlESVpep0fhTlWfr5AiEAxIEQkV3lMtkLfS059xYrKl1vjeYIMU8VMjdQgigC6Ek="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.6.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.6.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^0.7.1","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"gitHead":"278d05fcc714636eeedb3959bca80c20c19a61df","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.6.2","_shasum":"77741638c6dc972e503dbe41dcb6bfdfba499a38","_from":".","_npmVersion":"2.8.4","_nodeVersion":"1.4.2","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"77741638c6dc972e503dbe41dcb6bfdfba499a38","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.2.tgz","integrity":"sha512-bpRrwcmF2FELy0olDACeUheUM6F4vHLWHVXpBhEXoJrG5lPQ4Yr8qYDGKH2A8NVtBb6eKQ4+pU8lBZVv9Bq1lQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIF+UPMVWHMm4EowKplOIDvxK29KLxTjBIxgRbAlc/h8WAiAOR4R3/4deVYJQhyoSugo44bnmEzvAyQH3zlyxIrvD/Q=="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.6.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.6.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^0.7.1","weak":""},"license":{"type":"MIT","url":"http://github.com/isaacs/node-lru-cache/raw/master/LICENSE"},"gitHead":"0654ce0b1f2d676a0cfc1f3001a097af9e7b0dfb","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.6.3","_shasum":"51ccd0b4fc0c843587d7a5709ce4d3b7629bedc5","_from":".","_npmVersion":"2.10.0","_nodeVersion":"2.0.1","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"51ccd0b4fc0c843587d7a5709ce4d3b7629bedc5","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.3.tgz","integrity":"sha512-qkisDmHMe8gxKujmC1BdaqgkoFlioLDCUwaFBA3lX8Ilhr3YzsasbGYaiADMjxQnj+aiZUKgGKe/BN3skMwXWw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDBpi+Q0hkCehAy2e320hZmr+1AhTLXpv1Y4szMw7YfUgIgTF8eBhEOm3GoYy2Bq/Q/Y4UzSXxlRwNPHg2ZAsTEITY="}]},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"directories":{}},"2.6.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.6.4","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^0.7.1","weak":""},"license":"ISC","gitHead":"aea58fc0a12714c6e1422963e7ebea66460ec39e","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.6.4","_shasum":"2675190ccd1b0701ec2f652a4d0d3d400d76c0dd","_from":".","_npmVersion":"2.10.0","_nodeVersion":"2.0.1","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"2675190ccd1b0701ec2f652a4d0d3d400d76c0dd","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.4.tgz","integrity":"sha512-HTGRj0QugHZO4kkaPcnILasgemYHYMTbg1Isy63x8brLmy2IFLyMeiHaRHYJShPFjtguSX5VV30b7bSDrurNNQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGDvNk1zdwqJ/nmUpMVVQNol8mAwRQjZKJI2/cZgjN4uAiB8hxxbNojz9ph65/9cL+eo0aLVab6MGso32Cg+JViEpg=="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"2.6.5":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.6.5","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","gitHead":"7062a0c891bfb80a294be9217e4de0f882e75776","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.6.5","_shasum":"e56d6354148ede8d7707b58d143220fd08df0fd5","_from":".","_npmVersion":"3.0.0","_nodeVersion":"2.2.1","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"e56d6354148ede8d7707b58d143220fd08df0fd5","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.6.5.tgz","integrity":"sha512-a07BiTXhWFUBH0aXOQyW94p13FTDfbxotxWoPmuaUuNAqBQ3kXzgk7XanGiAkx5j9x1MBOM3Yjzf5Selm69D6A==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCG92vBkUxJfivt6VwRuP4Am8WcdVCJnmBV9GaEeuTp5AIga+m3eRV8Nu375UPJiZJZa1ACiyIkNIRwz9pTk0dGA6I="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"2.7.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.7.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","gitHead":"fc6ee93093f4e463e5946736d4c48adc013724d1","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.7.0","_shasum":"aaa376a4cd970f9cebf5ec1909566ec034f07ee6","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"isaacs@npmjs.com"},"dist":{"shasum":"aaa376a4cd970f9cebf5ec1909566ec034f07ee6","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.7.0.tgz","integrity":"sha512-qh9Iy109GLbTZhGxk+cAUy7qkxwSd+BZerHSWoiyCAyOLr5VX3fSCKAVVeT/1pGGYtshkK0rNtrqmdGuwWu+CA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCBhVM9QZPb4QpvAg4U9f/0Gt7sA6M1IM1Ne72y55dbkwIgdRrpesIx/Ei/FUza+hZHlqo7l1jTHv1PFsKriJZgnFs="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"2.7.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.7.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","gitHead":"7414f616267078264b5459a2f27533711487c018","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.7.1","_shasum":"b665391c30582a2df9c2fbb31ed50193f93b604a","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"b665391c30582a2df9c2fbb31ed50193f93b604a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.7.1.tgz","integrity":"sha512-5vteep/DXRNAWd51+M2xNmZdkxFf37GIetCtndVdHfUqgr9CcmtkTKOJvMl6JTTX39xjqcbqCVNod9/yZohCdQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC/92ZX7x3OKMBAAC4TsPhtrCxQ4NsFozFfoU9dWpQqlQIhANLH4ajNqRQmviLe34j15AsoXbSj8tvgxPKfSSjUP91v"}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"2.7.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.7.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","gitHead":"c70ccfdadc7063ea19e82db5a178469510cabad5","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.7.2","_shasum":"73810d9a2da104d07519fdbaa3947895432c6b99","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"73810d9a2da104d07519fdbaa3947895432c6b99","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.7.2.tgz","integrity":"sha512-kyYOJPbezwHfX82vzYiogdM6rGsgMTTrNEvNdVNmdh9r30peY6b0+34V3piZrC7+KDYXTzdKImHp82sOdbTjUQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCUN3MIW6k0KaASoS2xyiAyDw9/yPIh3FPK4c8NhOBhowIhAIxivBVzaVBuoqdi6HcKoeI9dQsklGsGeb8k6fGMIK8p"}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"2.7.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"2.7.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","gitHead":"292048199f6d28b77fbe584279a1898e25e4c714","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@2.7.3","_shasum":"6d4524e8b955f95d4f5b58851ce21dd72fb4e952","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"6d4524e8b955f95d4f5b58851ce21dd72fb4e952","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-2.7.3.tgz","integrity":"sha512-WpibWJ60c3AgAz8a2iYErDrcT2C7OmKnsWhIcHOjkUHFjkXncJhtLxNSqUmxRxRunpb5I8Vprd7aNSd2NtksJQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDBtc1Ngt5qhJ/4DvWU1KP2KP/7FDiokFrDH4Zw6QBuDAIgYy2zEjlf/Wv5XUb9DTc+tuhqNRpbJTUEgMujVzRolQ4="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"3.0.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"3.0.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","dependencies":{"pseudomap":"^1.0.1"},"gitHead":"487ab824ec8515add9f4dc78ec12b77ea0b51d0d","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@3.0.0","_shasum":"65704ca44b10718bc401ba7e0c1cfb5b69422d5c","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"65704ca44b10718bc401ba7e0c1cfb5b69422d5c","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-3.0.0.tgz","integrity":"sha512-cx7+qk1tNz/Fd8ljPkosK36Il+3SAlofa/Rxn8X5u0mfZo+Yvt8YJD+vpaaxhXmQm3tE+jYTJ5AG02efOF59Qw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCID+FxCHLJZTmHfVKzRfp5IU/MgZmD8X3yjrV/NCXYw+lAiAKh5Bx8f6sfqxJ61RXMxmxEfMYIJUR0qZ+c4ZKeIu++w=="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"3.1.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"3.1.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","dependencies":{"pseudomap":"^1.0.1"},"gitHead":"f729777fc0af1e5c61d0c724fc8c0a56bfcf6603","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@3.1.0","_shasum":"695666a271c1364350e8256fee8657fb90a6eeb0","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"695666a271c1364350e8256fee8657fb90a6eeb0","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-3.1.0.tgz","integrity":"sha512-ctXgysQ+BDobe8dANTYs5GlRfcY+WtFuaXPs5erVchOv4ue5i/s2I+3fyUFKoaebxn9GadcxwqrzjyYrp4Izsw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIC2vJ1ddYfqe0Jed063FJHJ2cK3PesLmLrsCHX7DCT9HAiEAv4/V9IRhZV3zxr9bC9K+FBFdOO3So+GP6hx4LBMOrdU="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"3.1.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"3.1.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","dependencies":{"pseudomap":"^1.0.1"},"gitHead":"bdd31947533d1d91b17618f1a30346bc3eb9840f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@3.1.1","_shasum":"62e11a908886c69713d102ba7b8969c8315348f6","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"62e11a908886c69713d102ba7b8969c8315348f6","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-3.1.1.tgz","integrity":"sha512-foKHyugDDIuZpVyueQ9t5O5R/cc+0DUM1dOhn0TIjafpYJMj/jmm8bJEYLm5gsmzOf7oUQUCaLUM5Rqz12kTrQ==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIH8qwS3qaYHQlg7cmeOLoHPA/8ka0Prz8lnPTqxOq41MAiBbBoMAjWjo9xej7vwPa4DZKzZNyg9Eby5Jkw0ixOy0gg=="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"3.1.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"3.1.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","dependencies":{"pseudomap":"^1.0.1"},"gitHead":"fa470b7fd44e386defb6be5fc3ae61906a68cc6f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@3.1.2","_shasum":"2c108220c9a73d4f516e6f3147c2f8f5a8eb0296","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"2c108220c9a73d4f516e6f3147c2f8f5a8eb0296","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-3.1.2.tgz","integrity":"sha512-Lz/U9328AZ9LzQowUMxeqtC/KRVluT1Eja39HY9ENmOf+JxOb0V0Ft/AEs3Ns8L+Lg21ZlnjuJoHXrnIuVqgqg==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDp8yCUHd52L1WWZhauFe/Z0FvdqniqCgFlwbQTC6faswIgY6WaR/P96vCbmuU7fwQJ7EvAgNgIiCYkoZACPevW4Gc="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"3.2.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"3.2.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --gc"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"tap":"^1.2.0","weak":""},"license":"ISC","dependencies":{"pseudomap":"^1.0.1"},"gitHead":"50d2d39a6649f1165054618962a467caad861142","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@3.2.0","_shasum":"71789b3b7f5399bec8565dda38aa30d2a097efee","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"71789b3b7f5399bec8565dda38aa30d2a097efee","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-3.2.0.tgz","integrity":"sha512-91gyOKTc2k66UG6kHiH4h3S2eltcPwE1STVfMYC/NG+nZwf8IIuiamfmpGZjpbbxzSyEJaLC0tNSmhjlQUTJow==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCTMSP+Ualrq9erVXg5eeqO71baGSDnl3vKZM2M8jZbHwIgVJt8HHJvHgWdPqWqmuVNgZ4BCHY7ItKgIkhjzqGT1r0="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"4.0.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.0.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --cov","posttest":"standard test/*.js lib/*.js"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"standard":"^5.4.1","tap":"^2.3.3"},"license":"ISC","dependencies":{"pseudomap":"^1.0.1","yallist":"^2.0.0"},"gitHead":"da374d4776aaef443765b43cb3617e09c170a5d5","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.0.0","_shasum":"b5cbf01556c16966febe54ceec0fb4dc90df6c28","_from":".","_npmVersion":"3.3.2","_nodeVersion":"4.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"b5cbf01556c16966febe54ceec0fb4dc90df6c28","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.0.0.tgz","integrity":"sha512-WKhDkjlLwzE8jAQdQlsxLUQTPXLCKX/4cJk6s5AlRtJkDBk0IKH5O51bVDH61K9N4bhbbyvLM6EiOuE8ovApPA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHy1nmo8pjvRL8NqLSjXFapgwWY7ZCe9TyJxcWrDU8jSAiAO8K0kUZzI9vqT5/jq9MkrBDJYzcM7uNmtmtbgg8Anzw=="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"directories":{}},"4.0.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.0.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --branches=100 --functions=100 --lines=100 --statements=100","posttest":"standard test/*.js lib/*.js"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"standard":"^5.4.1","tap":"^5.1.1"},"license":"ISC","dependencies":{"pseudomap":"^1.0.1","yallist":"^2.0.0"},"files":["lib/lru-cache.js"],"gitHead":"6cd8c8a43cf56c585bdb696faae94f9836cb9e28","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.0.1","_shasum":"1343955edaf2e37d9b9e7ee7241e27c4b9fb72be","_from":".","_npmVersion":"3.7.3","_nodeVersion":"5.6.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"1343955edaf2e37d9b9e7ee7241e27c4b9fb72be","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.0.1.tgz","integrity":"sha512-MX0ZnRoVTWXBiNe9dysqKXjvhmQgHsOirh/2rerIVJ8sbQeMxc5OPj0HDpVV3bYjdE6GTHrPf8BEHJqWHFkjHA==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCaq18b4co110VRt/RIa1T8tuhNNH/y0JMCrNxuk4EapgIgLPKoHASI9wwAp9fGzDhS6kLS6vE41iJCpzOLJDwAacM="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/lru-cache-4.0.1.tgz_1458667372415_0.8005518841091543"},"directories":{}},"4.0.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.0.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test --100","posttest":"standard test/*.js lib/*.js"},"main":"lib/lru-cache.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"standard":"^5.4.1","tap":"^8.0.1"},"license":"ISC","dependencies":{"pseudomap":"^1.0.1","yallist":"^2.0.0"},"files":["lib/lru-cache.js"],"gitHead":"f25bdae0b4bb0166a75fa01d664a3e3cece1ce98","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.0.2","_shasum":"1d17679c069cda5d040991a09dbc2c0db377e55e","_from":".","_npmVersion":"3.10.9","_nodeVersion":"6.5.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"shasum":"1d17679c069cda5d040991a09dbc2c0db377e55e","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.0.2.tgz","integrity":"sha512-uQw9OqphAGiZhkuPlpFGmdTU2tEuhxTourM/19qGJrxBPHAr/f8BT1a0i/lOclESnGatdJG/UCkP9kZB/Lh1iw==","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCmSO2l/oFVSA4sBxmSAlrAImYODkWRDAhgwGKRmMxhFgIhALnVcH6OWWi7UCKJqazDrkoxsbXRxpXfwf4qBgrnDdbB"}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/lru-cache-4.0.2.tgz_1480273800672_0.31606275402009487"},"directories":{}},"4.1.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.1.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","posttest":"standard test/*.js index.js","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"standard":"^5.4.1","tap":"^10.3.3"},"license":"ISC","dependencies":{"pseudomap":"^1.0.1","yallist":"^2.0.0"},"files":["index.js"],"gitHead":"1a77f87d74b46715b80acc3f6b44c12d030e9902","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.1.0","_npmVersion":"5.0.3","_nodeVersion":"8.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-aHGs865JXz6bkB4AHL+3AhyvTFKL3iZamKVWjIUKnXOXyasJvqPK8WAjOnAQKQZVpeXDVz19u1DD0r/12bWAdQ==","shasum":"59be49a683b8d986a939f1ca60fdb6989f4b2046","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.0.tgz","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEKWaq6AySPJBJ4oaveMzGH4sEWPQkdJZ49CQ80GE8gFAiAivRpvLhcEBgthx/3YsAL9j7/rHFZ8AVpgYQauC3g8rw=="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache-4.1.0.tgz_1496771655220_0.868791145272553"},"directories":{}},"4.1.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.1.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","posttest":"standard test/*.js index.js","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","standard":"^5.4.1","tap":"^10.3.3"},"license":"ISC","dependencies":{"pseudomap":"^1.0.2","yallist":"^2.1.2"},"files":["index.js"],"gitHead":"e992f26547a575299fc8d232580e53229393ea7a","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.1.1","_npmVersion":"5.0.3","_nodeVersion":"8.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-q4spe4KTfsAS1SUHLO0wz8Qiyf1+vMIAgpRYioFYDMNqKfHQbg+AVDH3i4fvpl71/P1L0dBl+fQi+P37UYf0ew==","shasum":"622e32e82488b49279114a4f9ecf45e7cd6bba55","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.1.tgz","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBDJphxrBxrupe2xxWX8uMBA2gD9BGg61RXALU68NTw6AiEAmzcYeuSHw4o1VhrYxdEsm1uCS79VY2ibv/jodTnedgY="}]},"maintainers":[{"name":"isaacs","email":"isaacs@npmjs.com"},{"name":"othiym23","email":"ogd@aoaioxxysz.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache-4.1.1.tgz_1497150046014_0.012352559482678771"},"directories":{}},"4.1.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.1.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","posttest":"standard test/*.js index.js","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","standard":"^5.4.1","tap":"^10.3.3"},"license":"ISC","dependencies":{"pseudomap":"^1.0.2","yallist":"^2.1.2"},"files":["index.js"],"gitHead":"2a95eda2a22b281f3253304231b2bab4432e2f8c","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.1.2","_npmVersion":"5.7.0","_nodeVersion":"8.9.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-wgeVXhrDwAWnIF/yZARsFnMBtdFXOg1b8RIrhilp+0iDYN4mdQcNZElDZ0e4B64BhaxeQ5zN7PMyvu7we1kPeQ==","shasum":"45234b2e6e2f2b33da125624c4664929a0224c3f","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.2.tgz","fileCount":4,"unpackedSize":17609,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCYsTsw+LGV7h72h5Xo6xuqb7rMOUSoFCEPKXEy2KoCDAIhANTbSnR8ICB36Gx6vKn3M60Ry5ciE55m/W7BsCRk4ljv"}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_4.1.2_1520531913886_0.19100220467390994"},"_hasShrinkwrap":false},"4.1.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.1.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","posttest":"standard test/*.js index.js","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","standard":"^5.4.1","tap":"^11.1.4"},"license":"ISC","dependencies":{"pseudomap":"^1.0.2","yallist":"^2.1.2"},"files":["index.js"],"gitHead":"9c895c3045b4decf49bbbd7d5171f0be2ff86039","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.1.3","_npmVersion":"5.6.0","_nodeVersion":"10.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-fFEhvcgzuIoJVUF8fYr5KR0YqxD238zgObTps31YdADwPPAp82a4M8TrckkWyx7ekNlf9aBcVn81cFwwXngrJA==","shasum":"a1175cf3496dfc8436c156c334b4955992bce69c","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.3.tgz","fileCount":4,"unpackedSize":17605,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa8N54CRA9TVsSAnZWagAASnIP/0DTXmV6eHfBolsGsEoI\nXAMUXMcWCyZvr6DOPJQCr4yk8dLPM2XSLpbf3OHA0iL5pKmEcsnfLwpLnVkr\n881WoMUsvve2wQg0vFopy1nq7HiJWm9fIwpWiQ7+ZzNPSKJZ4l2HyJoqhgf4\nwtf+MnFS9puiTnqZnJDS4pnw3scnnKzj0xeGBzV9K45ZH9i20dISxd/WK/Og\nJg6J1uqnnCmLcRSgDhwbQ+mtwXFd/aG0TnB7Cj21OcAScf01Z6NiVxVbDzLu\nnzOoQfh7EiyFxw9Mn7gJpONgIprLIliAdpek1QNuM+jx1etx4EOCAYn2S0qx\nRjaqqAOqosD7jGiCByWzl0iyCvGYYKs1796SmK9ivnVRpae7UDKLSpS9aBqw\nYIAnQyAK+BHBP7jvKvplvNxEvwGFxZyXQ7JMI/0dGQHeKp4wUStIMfqykRST\ncQuU9f6qhheDGEQshUFR4pC96o5kKsHAXnkRJQUYYaLMn1NUO8PtC7kbs6Oj\ntdTCKM6lo/JYthEfe3rBbPkLCgXoD25HGpbH6o4PxfMesPUSDmssYJ34ISLB\n2wLkQ5ciw3/OcrDLOHPAgykTpIjK+rt9VlWIXCKFVz1IDqmC+DhWh7oO9Nc0\n6xrI4e3njcViDR9ptV2dsrUileJFcLStOh92PQUYrVqoedXtGQt0tt2ptmu0\nkR0v\r\n=llkV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICU4mO+CH2vmK8GwZMDB9zne03hHTkkjn4VPgMq7qDMNAiBjLhff3HX4RU1wHpo/KWSpUXyigx3E8MG07aGIgCyfQQ=="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_4.1.3_1525735031368_0.027008230747383788"},"_hasShrinkwrap":false},"4.1.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.1.4","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","snap":"TAP_SNAPSHOT=1 tap test/*.js -J","posttest":"standard test/*.js index.js","coveragerport":"tap --coverage-report=html","lintfix":"standard --fix test/*.js index.js","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","standard":"^12.0.1","tap":"^12.1.0"},"license":"ISC","dependencies":{"pseudomap":"^1.0.2","yallist":"^3.0.2"},"gitHead":"099689df17f0d5de2e15a92e83262052772649d6","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.1.4","_npmVersion":"6.4.1","_nodeVersion":"11.2.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-EPstzZ23znHUVLKj+lcXO1KvZkrlw+ZirdwvOmnAnA/1PB4ggyXJ77LRkCqkff+ShQ+cqoxCxLQOh4cKITO5iA==","shasum":"51cc46e8e6d9530771c857e24ccc720ecdbcc031","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.4.tgz","fileCount":4,"unpackedSize":17830,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9KNRCRA9TVsSAnZWagAAe50QAIbgbQAfTApPu0BHiF3k\n+X37PcgXsnnzihuIcKoxkXLuZ0UQGw9Aj4XPXSrYJo2cQlLBePZ4AyfKxHD9\ngfJDGLUlHT+CybKdk1Af6YCQjWHrnFk56og0N9P12+ens+HU53mv+WiCb4nz\nP5Sm5E7GbWJk8cCDM6FM6aVHnPAoUwbxL6EkQNXCz2tJT4y9QGYt8TKIvbRX\nlYDDlPj+mBqkXPUsko/SCLOtdQPdxvXZ2t8AKfe1CR5vjbzRE6E6eBuVWfE9\nZpPRay+S1P7r+irxGuF7Gp/eqRhtt2FBnrKCiyaiUIAnicbZCABbhGOtQOQH\ne6mAf5opVKL7kYa2DmZtxCE/4sTGY3yaC6ER2Q1/uyZSQJbQkTLJ1DxzQnG7\n+kG3PvTVcqPMC62A2jqaCntM3stf35+fSbGO6TNvpP+43b+HsilcbSRMcus1\nLU0xZNP/npNxp1MpIzccPJ2PxztsaoQI0/iNBFTN+LLSN8ITfRXk/XvUsuSI\nEvpxSJ6QO1RnoZ20VBodTeDAZM+vc6deFIODeF3d0CYx9jjcixqXHUQaaAcL\nSySCXibQCTItxpycwxYkoNgPHie80sP+adSO9tM0tujOpYi+c6ICI0bkrZwu\nXMM+U7amqPd/D4/4oZgowSEJUOdP0gkll+270XBsTQd623t00TuM1rQsDJPn\nthdz\r\n=J1WG\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDyeN4zo1oY8qcl2cwkl9G8lnB+NqpMyiaAJhWoxvZtIAiBBIIlh9OnbY5v/MwsbQNkYXsBYINvbNxcMr008XB+D1g=="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_4.1.4_1542759249101_0.8740159848771953"},"_hasShrinkwrap":false},"5.0.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"5.0.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","snap":"TAP_SNAPSHOT=1 tap test/*.js -J","coveragerport":"tap --coverage-report=html","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^12.1.0"},"license":"ISC","dependencies":{"yallist":"^3.0.2"},"gitHead":"989d730321ebb338ff7aa434d0249d2f0d97d709","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@5.0.0","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-InxIcrhmeOXzY3n557oYAKV9HNTClbNAnjqizOci/fJiTrMa45iFd1OavQCIEyiHZNxM11fly2c39EH5st7ABw==","shasum":"de3d12fb64e4225b8d3eeda3c738f7d6ed007473","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-5.0.0.tgz","fileCount":4,"unpackedSize":14631,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9KrvCRA9TVsSAnZWagAAvz8P/AzH1/6DH2eP8ukWz0z9\nCVpr05UaSnaEsCTLl93D4G0U8UOfLl/ATNhGEVqGIr62w+vilNxuhzJ9GaKw\nTVG7sphGKDlmFcL1BK4bAy2AaGB4LHKFIpSLRHMN4k4RYTW7+5OWDdfRGwCU\nRxhNj9cTWcZMqclapxkq5gTfVKfWoZMc//h2n1Ny1mFlh5I1R3TmE6ptrIY2\nyO2vvKAfi5qyjAATzImVRe1AEoBxR1pLbYsh6mnui2sgTzsLnH/9yHliG2NR\n09ntFiYBb+/rTLH10+5G933KrJWwGv16u1sn1JDw50LBa1YdkXk26uHP4mfy\nbMOrF05VuL9cZpezkBl/EmSttlx92ZQqYtaQ7POM43y/s+U0Q9QHaZUbz0j6\nJT765pKqM/eBS52snNhouaxeLYYOcEV0LC2j8FWM3R6VKzcEEHED+Y/duaBN\nxBWgnZcP2VsSkwnyDRKU29dOCp4C+ogY2DE/bYVB3r8dMdoz7OB/SPJCN/Qc\nOo0K7czaOpAYFfKOCh/GnQEsgC8VBszTzRuG52ldy2unrORDa1GH7h/jvTQ1\nkg8LrkERA9YI47fz2nLjb7qz+5uXJH2RtpxHJak/lCnq5X9WS0lhJ9UxAc4I\nIHKVPAR1ScxGBXaPT1gfoKgBfduItSVY4nFNDulB8ItNEyJkMJnRI3bFCsJF\nKFrm\r\n=mplu\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGWbCYea3AKdQhssbjkfARenxvSBpY/lTuLVVVXtEDmfAiA/HA6+lTNsbHK/GIExppLFkWHt3HN//1ODkSTG5Z42tg=="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_5.0.0_1542761198629_0.7454856979770508"},"_hasShrinkwrap":false},"5.0.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"5.0.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","snap":"TAP_SNAPSHOT=1 tap test/*.js -J","coveragerport":"tap --coverage-report=html","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^12.1.0"},"license":"ISC","dependencies":{"yallist":"^3.0.2"},"gitHead":"54a9dc48cbc1a3a838e80d6f400bc5efb2bfc666","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@5.0.1","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-g7SHQ09RoBCtU0OxKr5XeyoeYuRXD97yTO1YOuvPeSzpbKtKVh5hqYUJGNvTGsxLEKx375o4irDnMZw8F8+kow==","shasum":"44999c73102eb665b221313ac80ddde9bac287cf","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-5.0.1.tgz","fileCount":4,"unpackedSize":15121,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9K84CRA9TVsSAnZWagAAUH8P/1rSge049REo5fxrNaVh\nVZn94c+5/LG6p/4faGUt6U15EClVHN2WmVo56sxJC4QZQBTCvhUHJ91RM3To\nYjQUVs6IfLUE41ERHEOX9AmMvS+7PIvSmSUl1Y7/sVpgDZ2IiKxS/Ra8jRWn\nADiwwLM1klg4VKT4uvnrAQV/TAaSSU1Evwop1P3NZHcSxaong7qa1urHhuSc\noD0jXaEz7TYXzJlWQjFN+j6oMLo2lzmBE0lpezHJH6p1TiiGjpLMomWpHbdw\nO2PFzviLDdRW4ZbtfqyLOszFLqp/YpcT/5bzI8dFkVefjam22oiIDgrVrPQ3\nW33PUGdJhNkZwyj5D8dXpRqA+j0DtZezlkk4X6XCpRc8MuS0I10SqIdQ9ApW\nRn7gnDvUV/JHkb4DCwVIIA6GzzWfpB1u14dcGmFJLlNhrwv3HN5wonvRVgH3\nMx4/qeVPyVSUdyM+yyV6KSxM3woNqiy2nTccveRabwWhDnE1jyjJ7kUqRUrH\nx9FDNDXrY+3ciOKdCxM41/zKb5fFM/fsuNcnqZWSTELVSYMjJLERotqbxuGM\nqZ484/bbNA5OyRi7uG6bXrAoRAZahG9Utot6uJukWjDOjJwtOuUArzUdz40z\nlcr91EL2Y88zw4M4EXYjjLJOn8mrF63wPzNoBIXJbP7nxJ2iLdIqepaU6zUy\nxHve\r\n=84q6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGQXswT/al9fj92uUDWvhKhaSPsLnBtfDzeJs2/nSn0TAiEA21IR4/ulHktVxgXIKNDPuiaLmvyUQlsr9QLPlVpNuZA="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_5.0.1_1542762295972_0.4767621080205895"},"_hasShrinkwrap":false},"5.1.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"5.1.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","snap":"TAP_SNAPSHOT=1 tap test/*.js -J","coveragerport":"tap --coverage-report=html","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^12.1.0"},"license":"ISC","dependencies":{"yallist":"^3.0.2"},"gitHead":"3c2af5a71cd561b6d76693f801af41a5047a90d2","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@5.1.0","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-a+QQK7jJaNExd68avUHSF8nnY6xDJRPlYKn+npF1Xv/QLI3Hs59vJpDtIhtZipvEwgcqvefDbADsgVfKOacmDw==","shasum":"3f6dc53a2123619399699210608cf144467469cf","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.0.tgz","fileCount":4,"unpackedSize":15614,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9LOCCRA9TVsSAnZWagAAVVcP/iR8blR92B/b0h+/61jn\nYaaF4yIvm3HyxMNPpgXVtBJn1T65I0juR4EGHMcdgtDjAd7IojC94LdjXOJO\nZz3Sx3EbY2XKc5mF7gCR4xmCOUaCl08vl0TKclsqOYB0+brOvdwRs+Bd+A/E\njxHQyYJwqsldnDU7hPn/zwWRkvkOQ7x1seKqDHs/T7GCau01+Ywm/7rQbpT+\nzvO7pl+3zAagZv2nMh6lcy5fHJsWo3zip0Xr16GPJEEp2ahYjSAuiPAJQkX8\nhMpFCDHou69j1Jw7epnZedaLhvvhNNA9ZI356S53AwgJN4pd5Qq096I7TDVx\n3PTBx93fHmtcuQEtLjMAa5R6CeBH8gJcd46HWKkr3tK94TAJ3GxmXiJNtLLx\nsNcQFICHK4YWehC++8Qhu6Kz+828Kgg5gKNOrOmF71P3e0faeN2Yez/7XahS\n5Gv3blxnEp3g+K8n1ymCVVq6GA0YNAesFHi/TQ7yW9dTdf8kWpZrIJupMoKS\nTAykiRfBZO8EHw8VwLTzTreCjiFPfUh5kPTYJBN6CXZbltAdLgQg6iNgcRxt\nPCzS3bwPzWrb5j9fQlM0O8wFgpSzDmBB3OHI3eFPWKkXj+eKQZCcwYNGs5Al\nfn3g9XiAeQQDNZBN5BuJxRAaE9CKPWAfbibV4ywUpyxAn1hYhQXVIbyH49Hz\ncTYA\r\n=s5Fu\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC5FtWCWeuZSRffvPAJb+RjOyNK57Xx5EJRP22u4Ls/zwIgEqeIvdYFsht13dju70OdF1r1NO/iE42OqBQtFiW6HLs="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_5.1.0_1542763393628_0.982190355130331"},"_hasShrinkwrap":false},"5.1.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"5.1.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","snap":"TAP_SNAPSHOT=1 tap test/*.js -J","coveragerport":"tap --coverage-report=html","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^12.1.0"},"license":"ISC","dependencies":{"yallist":"^3.0.2"},"gitHead":"a71be6cd547d28b24d28957a15b10cd3eb34555a","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@5.1.1","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==","shasum":"1da27e6710271947695daf6848e847f01d84b920","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz","fileCount":4,"unpackedSize":15714,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9LiOCRA9TVsSAnZWagAANvIP/iNd0BQp0dzx3440jk/D\nQK4yzdNKtv688NqB4JXeoMaA7945hmh96AvrDqeVYd74kp28R8KZ+yln3TCA\nlOqzraf2kwT2giu63CMfACQMBH8u5BjRThEuHdY+S3exJsnkRisoDhyS/7DJ\n0I4gVdRy8LMfwO+UiTkSysmOTb9Kz4BbNvCCUyyB9824oXuqECKibJoaEeTn\nn6O0JuFfQUygt9di18iozjq3CmO31pq3Dht90sTb0pLmChCMgg4m3dcg6g2H\n8CCO7/bHg76TtrC8eb1lkJlb2im0PjZN3OYJ0vY0aKQW6P79V18Rp0UGgK3x\noO7hZ2xiPlgug40kBGziPeYsPwpwjiMMDhnExkkSQarxf6NtuJ/Sj0+tTWza\nOXreTmMwt9MmWvbhVDD81svZ2YgZb5VfQzsRyE2WRVIJZwxhaQ4x8dlJSq+p\n3JL4K9qkcPPPWV+JJNDdcSTQVuw0deiUOsqSRMZD8nXvvN98/ugTf9rCvaev\nF+YyxIi+5hYqNYO37tG6WXTU5ADFqb1lf/7agpIAzF0pyuHkUEilk707+f/a\n0vZ+sCp9o7hHRpelJjHl6Cy6DrxE92SyHHHZ8rZmwupPkAS13lyWIRuqqBel\nJKtTxc9SxgxgwWJnLz1uW99gjzLMcXA/wN28oamaKtFpuwlt608NY9CES/Hq\n30nI\r\n=Zq/B\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBILagLs1MuDQ/Y7qp8O9PXXdLhCeOk8J5ujwiwVsYLkAiEA5cMZ+LEnDglkeaNzSKY8MvrgqE/zh7RfVclS6y/+0dE="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_5.1.1_1542764685228_0.235338811270295"},"_hasShrinkwrap":false},"4.1.5":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"4.1.5","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap test/*.js --100 -J","snap":"TAP_SNAPSHOT=1 tap test/*.js -J","posttest":"standard test/*.js index.js","coveragerport":"tap --coverage-report=html","lintfix":"standard --fix test/*.js index.js","preversion":"npm test","postversion":"npm publish --tag=legacy","postpublish":"git push origin --all; git push origin --tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","standard":"^12.0.1","tap":"^12.1.0"},"license":"ISC","dependencies":{"pseudomap":"^1.0.2","yallist":"^2.1.2"},"readme":"# lru cache\n\nA cache object that deletes the least-recently-used items.\n\n[![Build Status](https://travis-ci.org/isaacs/node-lru-cache.svg?branch=master)](https://travis-ci.org/isaacs/node-lru-cache) [![Coverage Status](https://coveralls.io/repos/isaacs/node-lru-cache/badge.svg?service=github)](https://coveralls.io/github/isaacs/node-lru-cache)\n\n## Installation:\n\n```javascript\nnpm install lru-cache --save\n```\n\n## Usage:\n\n```javascript\nvar LRU = require(\"lru-cache\")\n  , options = { max: 500\n              , length: function (n, key) { return n * 2 + key.length }\n              , dispose: function (key, n) { n.close() }\n              , maxAge: 1000 * 60 * 60 }\n  , cache = LRU(options)\n  , otherCache = LRU(50) // sets just the max size\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.reset()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\nIf you try to put an oversized thing in it, then it'll fall out right\naway.\n\n## Options\n\n* `max` The maximum size of the cache, checked by applying the length\n  function to all values in the cache.  Not setting this is kind of\n  silly, since that's the whole purpose of this lib, but it defaults\n  to `Infinity`.\n* `maxAge` Maximum age in ms.  Items are not pro-actively pruned out\n  as they age, but if you try to get an item that is too old, it'll\n  drop it and return undefined instead of giving it to you.\n* `length` Function that is used to calculate the length of stored\n  items.  If you're storing strings or buffers, then you probably want\n  to do something like `function(n, key){return n.length}`.  The default is\n  `function(){return 1}`, which is fine if you want to store `max`\n  like-sized things.  The item is passed as the first argument, and\n  the key is passed as the second argumnet.\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  accessible.  Called with `key, value`.  It's called *before*\n  actually removing the item from the internal cache, so if you want\n  to immediately put it back in, you'll have to do that in a\n  `nextTick` or `setTimeout` callback or it won't do anything.\n* `stale` By default, if you set a `maxAge`, it'll only actually pull\n  stale items out of the cache when you `get(key)`.  (That is, it's\n  not pre-emptively doing a `setTimeout` or anything.)  If you set\n  `stale:true`, it'll return the stale value before deleting it.  If\n  you don't set this, then it'll return `undefined` when you try to\n  get a stale entry, as if it had already been deleted.\n* `noDisposeOnSet` By default, if you set a `dispose()` method, then\n  it'll be called whenever a `set()` operation overwrites an existing\n  key.  If you set this option, `dispose()` will only be called when a\n  key falls out of the cache, not when it is overwritten.\n\n## API\n\n* `set(key, value, maxAge)`\n* `get(key) => value`\n\n    Both of these will update the \"recently used\"-ness of the key.\n    They do what you think. `maxAge` is optional and overrides the\n    cache `maxAge` option if provided.\n\n    If the key is not found, `get()` will return `undefined`.\n\n    The key and val can be any value.\n\n* `peek(key)`\n\n    Returns the key value (or `undefined` if not found) without\n    updating the \"recently used\"-ness of the key.\n\n    (If you find yourself using this a lot, you *might* be using the\n    wrong sort of data structure, but there are some use cases where\n    it's handy.)\n\n* `del(key)`\n\n    Deletes a key out of the cache.\n\n* `reset()`\n\n    Clear the cache entirely, throwing away all values.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recent-ness\n    or deleting it for being stale.\n\n* `forEach(function(value,key,cache), [thisp])`\n\n    Just like `Array.prototype.forEach`.  Iterates over all the keys\n    in the cache, in order of recent-ness.  (Ie, more recently used\n    items are iterated over first.)\n\n* `rforEach(function(value,key,cache), [thisp])`\n\n    The same as `cache.forEach(...)` but items are iterated over in\n    reverse order.  (ie, less recently used items are iterated over\n    first.)\n\n* `keys()`\n\n    Return an array of the keys in the cache.\n\n* `values()`\n\n    Return an array of the values in the cache.\n\n* `length`\n\n    Return total length of objects in cache taking into account\n    `length` options function.\n\n* `itemCount`\n\n    Return total quantity of objects currently in cache. Note, that\n    `stale` (see options) items are returned as part of this item\n    count.\n\n* `dump()`\n\n    Return an array of the cache entries ready for serialization and usage\n    with 'destinationCache.load(arr)`.\n\n* `load(cacheEntriesArray)`\n\n    Loads another cache entries array, obtained with `sourceCache.dump()`,\n    into the cache. The destination cache is reset before loading new entries\n\n* `prune()`\n\n    Manually iterates over the entire cache proactively pruning old entries\n","readmeFilename":"README.md","gitHead":"57658f575607a44bb2fa38dd0e43d74835e42dae","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@4.1.5","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"dist":{"integrity":"sha512-sWZlbEP2OsHNkXrMl5GYk/jKk70MBng6UU4YI/qGDYbgf6YbP4EvmqISbXCoJiRKs+1bSpFHVgQxvJ17F2li5g==","shasum":"8bbe50ea85bed59bc9e33dcab8235ee9bcf443cd","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.5.tgz","fileCount":4,"unpackedSize":17843,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcACavCRA9TVsSAnZWagAAApYQAIClk2BJDU+mzS2L6g/6\nWU9peKlytceanWLW6zivfwQc7E0gNOb0NXY8XKFOxAibBoYStcKvxTqPLR53\nCOowz/CMKFHnyoZd+rPvN8Tt6So58+sk6k03W3M81vb3IGB1Sjx5scSfjHS6\nIzxR/BSRJ2HIPSfvs397Uxm82YmZEVLaDE0C4bPzXq7M8FWRKW8GV16InLoH\nWoIh/XDs0Q2dSerWlI96HvoE6UybkY/kfkpL3957AAUap3vTj4N0bDl9DKt2\n0lcbm/Ba//zYLjbXu4zkCDNKgPr7lWioLRSH0JI2ykoqlDsuz8GEqye4dvc0\n/SkIpj+DR0k1qnwoLFQeKqCa+bIZO8+y8zqKqauoitoInhd73hZR57QgaThF\nc0BWs19VYfKzG1/OVzgHrFxJwP9fqiQb0r1oJ3jz4HI/4z0T4sY5fvKGGRRa\nip4wOeLr3ASRBGNGkH4q0PKbciZtZ08vt82+vdknDEoGc/ld+HC+NVmUlALF\njveTwVK5jB+1iOv/r7QW8Y2bhA3b0hyxTL8aAozG1TlbHhikZ+Ueq4wG12mn\n/hJuq+YsF7eQIK6Ifn8+V4iwo2wGzCvFKYFcd9f2qHQVYdGIUeAXsDL1JNeX\nW8lx9eGsbFfX+xzLfqw692GhCOKi9QTPA8Qzeim8af/wnuBMUOqJNxysLaOT\nb5/m\r\n=3dPc\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEl9zRq0rk/wyZSxwWMPt3xZgWMlhZnjdrO/Z3i6ImV4AiAcOsgAIOH4Ts+Sdje34lTHKIyLc3JZBLdF8Uf4cxVSHQ=="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"},{"email":"ogd@aoaioxxysz.net","name":"othiym23"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_4.1.5_1543513774289_0.3522451077999784"},"_hasShrinkwrap":false},"6.0.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"6.0.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^14.10.7"},"license":"ISC","dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=10"},"gitHead":"a71e08008f2d25442426d0d26e8133dccc2ca9a5","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@6.0.0","_nodeVersion":"14.2.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==","shasum":"6d6fe6570ebd96aaf90fcad1dafa3b2566db3a94","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz","fileCount":4,"unpackedSize":15643,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfCQ7bCRA9TVsSAnZWagAA+F4P/jdlPS14NkOtYnSPFZMj\nDC3wsaM3hYlUtdiVJKDOTjhKdcgZ6V2FgXDq716+5rbaq5t9Von4FeweMgp8\nnloQVB1CRctlLPIZRoV4Mje9K5rA4Utb0lYqQk52SIWBN+xJDyyefZneKPnQ\nZSGaXipOLLYPF59rBaCvkxI/Sx7NKELQeXZhGeZWgUPNPejFC+qseoFfugtP\nVk2AKuejsSsdzLbdxADE53k720y/D/biUK0cmQcV7yTAqo/XaxdmRNwr34Fd\nNJ2dbm87BEjC2hGs4WS6OhoPFdIN088c6vrilKerKgrDxHCzHJi0E1oZ7IeX\nByhOLk03SScXYdmibzm0O9iWrTuBEJm6toEToJhNziv/HFTgDlhm3OajDHEz\nrb1cV38QwBcqE0O8X5uLQ0nZYCMczliwWKwMhkcsXmEA7wsiObM4Y3CVnpGl\nDurnfCmoAG0x+8NVAKeijXPgl0T/7TgtiByyfuH6kukF+URg0VYBbqFFz7AP\nbOxA7RZIDNaLeYjn86iGYyNtXQPwPtl6Q3qy7i4YlncJsQb0pDqgp8Qn2ib3\nYnGOXf+FxVYwQwGv2OCCWWCT6aT2bQk5SS1qaEOrMHNKTN5PPrXa9oXQb7I0\nnNTAy9YBjlEwfW7fHvX6xa9IH3wDT/P8MYmYHEwbpH6uB2y2u/zWCuROQMzo\nuAr8\r\n=B5wU\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDH1h04jqNTVbunN2inimDGmZDFw6TYP2ncxfDMuXattQIgJo4b+w5Z8V0GYbPSr/i4M67tO8TctMKFGy77xlJ4/Tk="}]},"maintainers":[{"email":"i@izs.me","name":"isaacs"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_6.0.0_1594429147159_0.2608141604867613"},"_hasShrinkwrap":false},"7.0.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.0.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"gitHead":"a9b57257c36a6746eb9c7d216df01f430701ecd9","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.0.0","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-7YrVYWtAmT6LubLqn/EdQrATm/DmBL10s7cDasBTvCgtAtU29UcRtj6MFi7ihmFOlAwOazQLIQq8pHQylKRhOg==","shasum":"50e43c1dbcf17eae78611d8abc0869847030740c","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.0.0.tgz","fileCount":4,"unpackedSize":29309,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiAb1hCRA9TVsSAnZWagAAd/YP/27zAvQ9Xp1/yYbOJ/8f\ndr36JxVozkq7PPCr2ylVR8UveQbrcPERNFuzIL46YUtFvSxW7HNAbqgttFur\nhU3/gZutYa1/5lcTxXo5I94P785D+AEkLnZU8NNPG+TOy7v/6fXF7IlHY/Xe\n3PeO7MtXTY0KPQBus6C1ShUj1klglLUuZZwrOvYGgLHl491Vyrw7DQIXuVu0\nHBhJGohlLMazz/NM/HUgxXec4ztNSU/fMaDeBu3IyH+gXhe0uVbk5suII4AW\ncGpuc2pPLYDQPVX51m6FPh6mNT4mBBzBNuufQAoSMj9UpWpEol8lCZQRtc8Q\neyIqfu1kBhEjdYnJctMMYFlA+NoeIRWa2Orkvq4oWcZbJgPPJsbVookiUSGb\n66tGBox2bTZ7AxnRVrv81aHi0ST+t+SuWNbMHpBJHuafppEhiR+KSvvXk6jN\nn8iiOeR45fqhTgqkNaYhTtRPOqjxCEhsdPhq0pLjyjEdh5KS/jKa1a5BDAUB\n68lnZ+L2YD/gvgZ/BivyurahVuipMkTiqctTdD1XNCT68rkLuy/vaFpIXKOc\nQOtTDdOQEudXzNJR8aYBJan9Nz2kih0iQMGrUkTMi3GPPIvK2XKOD3N93zLy\n3bPIYsT3jcy3PcKg0RPOTHAD31KEuXqKP6/FKNpkM7ep8P4tkjiK6CD1CRVb\n6h9J\r\n=Dc85\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICOjsOReoA8zPWc0u57TUJ+fQ4ly/I6xP/bqJYkWqhiZAiACcGclqRerYCKVSDGU7M4W83Yi6GRlJJ/CkHrldCzBvA=="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.0.0_1644281185634_0.755406333862241"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.0.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.0.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"gitHead":"51cda550d529c460b392a3c915f9d1124a5f878d","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.0.1","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-A6xsa0F6rWat7YXjt0gOEIK6uEjP0DBet4si4IY1+vkYPmcfyfTqdjU8GLRWcoQU3x3YlQ8m3kUlLfYvlg4WRA==","shasum":"aa4d4a97a176e1cff29504ce125ede5630078aae","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.0.1.tgz","fileCount":4,"unpackedSize":29302,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiAb+RCRA9TVsSAnZWagAArm4P/0mKFLkRYTeaoc3EhLPx\nhGQLzUNh02K/X/WY+qSa6rdB6qfeJwi+rFymrBSgHpMWEjyUHIAenRBFaQ71\neNA0lWDGwlk94MW2HHWB1aWPIwm4MY1+KEhtt5IN4yjDhjM2pCrrv1s8DWQk\nOfx7wzXZ1qvJVG3R40AMUDwM0YsGHNlcAGS+pPyipUYgbXdizR35bVjxe6Lt\na5qzt0YJB9p5LFWaNvI5WEYHHwGgnqsCfRkbV/eFwC+FWSiri9jhAgoXXwUm\nLk75nwCG2moQB0HKlQpXVs74rv6dN0RnVkUSGi4Y0NjehNzsqT5EYX6eRG/d\nc5j4hlDFphqThWFY2Ds5M6Ob93aqoVBkvQmZHTkCVhA9clNsexD5fB7RGoe5\nHB+xKFCDecTjBFUHHUZEyNYRvsDUuNxzsJujT3HaGOwfW35KYtR3nsFoCd5J\n7MT7XsQtXb9gAh/k7xbnfnXCvvj+qYpegVdpGNhSjbp0Tj2+0oeZyU2ifud3\nE96DIpWxLdnY0LGZrsqSShRFM5a7bFuslzl+4ikcQP/iJNlO0fa3Jc2FMp7+\niyqYCjO/axX/Uf0iU3J2JxxwhBrf2B647IrQ4hztP5Os/W2IEF0HOQ4mVTf7\nzahUvZulLpDS7t6yQSkkFnvjsGsjk8Zjw1mlgF88bARy4vFlRSlKaNhme194\n+Z30\r\n=doDL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC9usAbto9mHzf4XbfXE3D4aop0bAZa6s1yhu4Y7VA6owIgC2lKmlPiVhALImHqFPjBsAzkkhX/ZJcGkFAeynlB/Vs="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.0.1_1644281745791_0.5842864070845559"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.1.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.1.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"gitHead":"0ee3152612b96d6f5b4b64a127b93a8676492c8b","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.1.0","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-nurMcfDB0KMoovula129I+tgpJZOy6goffYyl6L5Tnagg1HJqgUFGtymaUsmPqlbnmeBOohqngEiLZ39VMBwbQ==","shasum":"980f5b1395ea563db9fa075c033f109e28711023","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.1.0.tgz","fileCount":4,"unpackedSize":33744,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiArEkCRA9TVsSAnZWagAAbzgP/0SRhW1jLLu5s4UxjnqL\nxnnXjlzFmBADGhHjUnsKRSpuRwtuFCuoIYVl05d0N5PXm4URMdtp0S220XeX\n/QHRDxf0KoXKiRYKjIjJvIOK9RqsncgPjrR4+H5AOv0jlpq4J4Y2FXvAqqbN\nff6Y5zKZ/oSV1E/P5+97yEVWjZ2BNWDwmNfdIM7TBPjT2ceRXUdfvZm0Xspn\n++Zd6trnVfyZhb9f+ISh8rhI/bdKlh3ygUQ6L7lNlk4n0HVsIoYZyc3vxQH2\nBScAp7nQVM/hc8FN1KM+YOlkLAgdG30dxiWErnWO6pLLtqmzI+s6Niu6SIwc\nyuv64y7+JubcNbGXUhWn1xweQZrJAYHc87ERizPMvq+5LN4E+h/1sIWyYicG\nEDW3/gr0+d/e8hOJfMN02cDm/VnUUnZoalrltYmT5YVtt7PGNFoYiwfLBrQz\npJ6GhCezHLDhm7GRiHwCUeJ7XDcusbXoGoT5bs+NL31M8gaB0AhHIuzV/miX\nKBbvI/GYgr7fSD/7Tp1kFm/XrsHCtgumgF1aLoGQyTYdRyh3gAMIFuFh126Y\nDLqIwjPFXwc1Jncsdy0lbCCA2bfdNZfeCBCdMpWt637HrvcuIC9cMWOZc4Nd\nXE/Lyu78zqPxboLtA84GTToe6m0f6bTv9Hu+cODP5ndL9Vo2p9p8imNJHbve\nkke3\r\n=NENQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEonysLHmKaswWyOvezIFQk2OyYHn+1E2C1tLY/FDwa0AiEA7UqCwouulThEULXAwS3q4TrgvsvqXIRA0wP6hhjKWNE="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.1.0_1644343588416_0.46202560296111983"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.2.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.2.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"gitHead":"385bf7361acce2a0f0045f61b02cd114b4bc338f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.2.0","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-Lurb8qd5p16b50M9YsEBZGbgE3ZlatPkMLITGu/8HKRloMhgly88m5s7kyByu0bNn+e5C3LyyuScTJXk4nn+Tw==","shasum":"daff6b477c30eb1bcdcc7dc361fdc1f913c57691","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.2.0.tgz","fileCount":4,"unpackedSize":34539,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiAsYACRA9TVsSAnZWagAAvrEP/jdo03obrmX5XvChLfbg\n1PtlGk++PgoaMtGDQJDypLrx7wd6I71tB+rOXjFg00AXEgX5P6CO253D9V2U\nvQ/gSDaJqfKZAZrkNxdE9IKh8tmXohiAhDjQ8IK0AAjl2Y4Vu0dFhAaePNTp\nDmgBnxNI7TwwMGeKGEw68cyHTwwhRWsSVMDulvbB1Uk8hMX+bUr7VNpciGCF\n6S9HdMbKp4KcXlVAg6kKmTkhH5IUJNCrUIh94hPuyzX1GboB+BTPic12lkfT\n9qqSjmJTshtzDo9YKDrHMTvL99YjlPYunGbYGHNe03x3IiQ6LgIK15oKpgud\nNpuHDYtY4eNW5iaF3t1on5CRr7TPsVEMOJIghF8D1XhjXodJVIJY09J/XKd7\nRDiyihDphjazyfk5ocki7fLqpfionZXbrQ61QC/WPJTIrc5wQ/UBM0ruFXcx\nekrjCEvKgRc3/f1OgPVCmaH8S99MOMOZqPDuZmWs4zR8Ue4v6IezeETWBs02\n6ib/5i5hVVIHV9G292FFiJn1meKU8BRBJBfHoOimLHkrGov8zpy6ITWjPt0t\nlqz76OTHp2cZxna2TiAo4pdwT27XMkV/gm2sxS2wvgAM5w0n54Siyn4uqUFQ\nJTbVpZczezdbNUPoVzJTrJz4HVy2SxZPPgCEqOnIjmfgdkkPvwXfXZ/gkoRS\np4Nh\r\n=w7cJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBLrzjVngpT1IfRmfb5WCkyxSt8I+LqD2ohux6gGtrlyAiEA5QOVpEKFGYdoVt5hiyxddH+5eqSjUJk0Q88ApwStE3s="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.2.0_1644348928403_0.749574143670314"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.3.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.3.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"gitHead":"ea96cd5ccb59e2b96ddf717840d5f046f76261e3","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.3.0","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-itGqsGM9i3Jt0ZbEkYRKQ3K/Q61vOLNuUkmK0jyjt1VH76gfcvjHmPC6e9uvjSrKOP2aN3T9L1vN0nxQSkrAjA==","shasum":"475ed4a39610204d8d23b243e902ed074dd8052d","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.3.0.tgz","fileCount":4,"unpackedSize":36191,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiAwrzCRA9TVsSAnZWagAAXvUQAIIJ2bxYwbR0F8EPA1nH\nW88p821GR35RXSL/+x58Jg8O/vAy/9YAwnSNepHzPc2DrRqb2nmvBDzx3fkd\nU33QIfEzdKQ6N0wWlqjVdEw/EpgY0rJWK0f1uQfW3/AcNJuadHFKPs5MsSOa\nnP3xswPTPyrH2oU7TnafnomZ/zxtMTSzdBludsQOZKBX6WfUV4VA97anxoOT\nZ0Gh5KOxKJ1kVrOQ2fjkLtU0D4/iZ5GBPX4GkhZGKG/O82EbT+gLXyPPDsmj\nvnyIwyDpeiQ2CiO1qyaImxO+gZyWc+CAkdVXratBw7AGG/anRCeBulEgNIzt\nk6xRmya1TaqbAfabkqOxajOUQZZeAxDxAdQ6/dprWnf9zmtf8PpB3vsZ+D+C\nSY+eoHvNyfOCpLEEk37iPHmNwBxqXG0oQfzSNnbdEOa2wScgwc5wE1pQ7HXn\nXIe2kGPLN84wFz/B1nm+tezWU8HKftc7uWFVLCY/0vcg4Vcyw6JAS+jWLtPd\n+DzJ3OIurp4ZbuFZTYAVQirrvlmw5BIMSUQ2hkvkGMzgSM6WBgWVOrVb8HGz\nohhV1JePO77oiT+yqtzClbr1f9U13eHBmsiiH15MEuC/036ZUAFD1nrIW3nT\novreaeC63ShSEdvrGmBbdhNOffBwPkXFD+QjZOG9tkxY7jrkV9Mr5xvU9+PC\nUvpW\r\n=oibK\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGu/cPQzLT135hO4fmvhZT6qDgs1pfOMA/KapSI5ap8eAiEAibpRzr8uF9lQMv036aJDIlEJux/fB8/jUerj5EyHths="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.3.0_1644366579810_0.9272432594774989"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.3.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.3.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"gitHead":"13cd6baf5bbe8b427813db80d5f3791998e499af","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.3.1","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-nX1x4qUrKqwbIAhv4s9et4FIUVzNOpeY07bsjGUy8gwJrXH/wScImSQqXErmo/b2jZY2r0mohbLA9zVj7u1cNw==","shasum":"7702e80694ec2bf19865567a469f2b081fcf53f5","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.3.1.tgz","fileCount":4,"unpackedSize":36246,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiA9v0CRA9TVsSAnZWagAAMoQP/05sgB2Zv6OhB6fREBaw\n6i4J6oEypzY8MPQ1aRkfu57ee0PMdh+xihXJvgxvLda0dESyfmlZCLyNQKee\n5LPeC9s8RfGZaWnSYpcPtJQX12FUP/tHFLfMp80nPMr4gEf1nUecp8hkZ1VB\nMMbpXsSI+vQgPOowFGiN8/y6bQEv8zhU56DNmDkAjfUSEDJWvpE+d8q3VxyA\nNtU/QIrwCpmw7ZqKfBTbVimH1ZBavaDgPBIvh55xm27/Au3VyU4BruAmZo0i\n0H+5W7e7k+15HkUQkG5GifWdxRldUqJMbGs7ULTzyA8tPdfGdVMsmoaro0pW\nXlnvC6kZksCMFdhIhiESYS/6Zu/mecHZHincNdC0nKsB2pnu8Dyf0PvgI4Zp\n0UxRhkcQaM+JROT8DTksGuva1mKfV98SGuucfVl+ZBVvFme07ERKPrZV9upo\nKbQU8+5ybemNyMq4oFC8/bjJipVHwhmjH9IAhzZSQkHndXe6d5rvOJQBIjZZ\nJ/Be43fQhM7wvgG90ZfYweqkeZd6vGC8aJiEbyZnpmnMbqAIjvw2u2nlIgqW\ngq1FrXJCj2/Q/bB/hC9vzYSf4u6jDDcJSJAUMMrNrmwnTurOqAzdevXRmo68\n36u1/vfZLheatNtIJ7rXD5lZKgPfUJb2TnxWR+NZ1Iqcx8swpjsrII7ctxcy\nR/ud\r\n=ErU1\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDJLAoyWUBLm4TnGV3wCM8GHjyt8wd5T1iiGAIpMtYNDgIhAOVqkiweUtNHFHnCMgaNmJTKFn3aglajHMGOSTxaJcLw"}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.3.1_1644420084416_0.7876810834242707"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.2.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.2.1","publishConfig":{"tag":"v7.2-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"f01a2da54238513d4e33cb5ff2bbe97f26176ec6","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.2.1","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-2snGOz/Uzmbw0KRcJ67raVUsQkTmWsx2UcagmtM57Ci7q8bX45ILe7G+iwE6VjqyPMzz3b9J4jEjojBnZQIIdg==","shasum":"e8655de0cf28ed7ae7dda5710cad12a3fab90c3f","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.2.1.tgz","fileCount":4,"unpackedSize":34647,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiA9yFCRA9TVsSAnZWagAAuB8P/0G5BERZgrNM4b1F+UPX\nHnKSbmhxoNCZJoyaDGYVpw0+b0dD0jsevtZT40uZPhXpgCoHAnDJ8UHfsz9r\npro8jiQQdQh+Ow20sExPNp5W33tQqfJEowDlNFX9rqzEf/zSIUwJ1h4SROAv\niXG8OAWnIWUaUDNKKRS7kqrRackoEUFhIQMsrfHpIm2hZYF5A9LawPqmdksn\n3Vfx/03eXfJrscUaywZnz/ugLvPlJJ2xRPV9GKicA3P+70Kzsbe+XtIY+qaW\nhCN6s2obZ+T4s7kEdjkUmPEZitsgLs1phldUoDNxlAWjG6clYO430ISapo9A\n0Z3yDgNkgXjFruj2uiX71Bx3tejg4IvlZUH8AXCSmfUry5PB0hSVK59oHOPb\npIG0BAyaGXPj84qrXVVyi3rIbhgH/jSfycwBz0/s6wQVU2qmWX0bEheCvLdn\nkzWi9Hysg+TR0avi4Qh1yYImZcSmlRuyYWo3TZPgK8xN2cuG9esQtcRJnBLF\nrZ3SLaj7/2EgKYngGZI5odJzCGvGHboD44LEn+GM/ePCCybkCw4LOOk1uyu9\n2Qk468VrfOJwyPZMulasouSiuy4urtO+e60zYg9W3/syQw0eXi+Vo3+966ui\nZGToDnvdnPXRLBzOi6atzZMGrW2L5Tzoo1FaleLLzOCjKU2xxX3mRX9ObGbX\nsBtV\r\n=nEG9\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHCa1/BPR+5HfTZMuqa+F1ZDYGtrrbAFNFIz34EepdihAiEAgFv2b3eMI9b9R4fNEKWaF6xWjf/oCxCKWTm5FgVPIJU="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.2.1_1644420228836_0.5934694907030751"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.1.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.1.1","publishConfig":{"tag":"v7.1-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  stored in the cache.\n\n    It is called *after* the item has been fully removed from the cache, so\n    if you want to put it right back in, that is safe to do.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"121148a85bc0da3d1270aa8cf8c12556ff11fc86","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.1.1","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-qsTWhEwB7kSjf0BckLLUS/OVVk4lLKBFZZRUSVQw09AqFHq+zONgLH2jEW8rNJgTORH1d4sljDuUtjSgpbLO9A==","shasum":"b636127cc13931e6eaa2d8994382c7f73bab29ed","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.1.1.tgz","fileCount":4,"unpackedSize":33852,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiA9zmCRA9TVsSAnZWagAAjg8P/Azqm+Jma4Sj1PsMRVjC\nHj3A99ADMEkFVChkqgalQaCMm1ciDeidNhw+f5DaEUCUSba/pIkCh/zg4Lhe\nlxnzULgHGHhhULTgtv2Awwg9wpTtI8Op63YjO7ky+ocTcSwayBYaNf5k19SC\ntWPy/cJQjBXgRvDyjklLZnDnmeQYRL7W7FCfGHVDPHPKkfdivBNXMw5vtH2m\nNhk/2bKvmfZmCBQbAsMiDUW5VEjJjuQzMPZjJQbS2fU87aRdrXGQRg5D3GoJ\ntcDkh4DutVGnCtLwzH7l0laX3QKRzKJUD0SD/Dr3eT0pUwR3XoY8fesbYJE3\nlWGAGYpS/s5i9FGeC7STl1cExQn6D7Ugk8EuVqAdIr1ipqFKOmcPiLP1qv37\nHxkSmjMfMrDog0WSxKMBm8iicC7lApCthR2eSoA0EATrgVhc0qE7T51MkH3s\nWa2G83mxZFldkWugiQQlLTryMvE3cZX/4O98eh5Hn+xN3yrUYMxW89FQYf38\n29S4GDhc63SesOB5AOGznSuu8OAdJ9NVVVPhuzlmL8Uw6ZMFzXS27/YDuTId\nkFv2FSZD5zgmHHjp10dBx9vSAPA6cFWz/jFA8Q1t7kDpdZMWUy1CsSOWBzX/\nVfwwHrxGhOza+pFNiQHf32Tq4wRlgeNGEWaEH9fi5uUmScv1vgpqn7+ItlYM\nyv1H\r\n=uvMe\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEsqSnqM6smxkXB5JZVDbS3qa4EzmsEVtuV525La8tMZAiAZ+qbeJZ6gIKCbqEbI9rFi7gCb7Kywnn20duXre9lKqA=="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.1.1_1644420326615_0.8904005679247122"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.0.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.0.2","publishConfig":{"tag":"v7.0-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed, and MAY\n  // live in the cache, contributing to its LRU max, long after they\n  // have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  stored in the cache.\n\n    It is called *after* the item has been fully removed from the cache, so\n    if you want to put it right back in, that is safe to do.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed, and MAY live in the\n  cache, contributing to its LRU max, long after they have expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  pre-emptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.ttl`, `cache.allowStale`, etc.\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n### Internal Methods and Properties\n\nDo not use or rely on these.  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\nDo not report bugs that stem from using these properties.  They will be\nignored.\n\n* `setKeyIndex()` Assign an index to a given key.\n* `getKeyIndex()` Get the index for a given key.\n* `deleteKeyIndex()` Remove the index for a given key.\n* `getDisposeData()` Get the data to pass to a `dispose()` call.\n* `callDispose()` Actually call the `dispose()` function.\n* `onSet()` Called to assign data when `set()` is called.\n* `evict()` Delete the least recently used item.\n* `onDelete()` Perform actions required for deleting an entry.\n* `isStale()` Check if an item is stale, by index.\n* `list` The internal linked list of indexes defining recency.\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do that,\n   and use a cache such as [lru-fast](https://npmjs.com/package/lru-fast)\n   which uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys.\n3. If you know that the types of your keys will be long strings, strings\n   that look like floats, `null`, objects, or some mix of types, then this\n   library will work well for you.\n4. Do not use a `dispose` function, size tracking, or ttl behavior, unless\n   absolutely needed.  These features are convenient, and necessary in some\n   use cases, and every attempt has been made to make the performance\n   impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\n### Specific API Changes\n\nFor the most part, the feature set has been maintained as much as possible.\n\nHowever, some other cleanup and refactoring changes were made in v7 as\nwell.\n\n* The `set()`, `get()`, and `has()` functions take options objects\n  instead of positional booleans/integers for optional parameters.\n* `size` can be set explicitly on `set()`.\n* `cache.length` was renamed to the more fitting `cache.size`.\n* Option name deprecations:\n  * `stale` -> `allowStale`\n  * `length` -> `sizeCalculation`\n  * `maxAge` -> `ttl`\n* The objects used by `cache.load()` and `cache.dump()` are incompatible\n  with previous versions.\n","readmeFilename":"README.md","gitHead":"02c726f446fad5014890564a18863bda025a604d","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.0.2","_nodeVersion":"17.4.0","_npmVersion":"8.4.0","dist":{"integrity":"sha512-JyQNYHSkvbRX0FT5QrL6KxWghAZMz57P9xdkWmDHvi0PG9IC341q0fLUK6Ax0DV85+AsU7LMt3XFLImggzj98g==","shasum":"f5bd5d54960c7247ef6622f7af65578bccd9d974","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.0.2.tgz","fileCount":4,"unpackedSize":29410,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiA90zCRA9TVsSAnZWagAAoe4P/1n8/godLEjNiISQCUvO\nL12+MF7qifx4nIIid5REjYgNBMwi60JHWP9UYcC7HQm57zlzf8Kv+Zn3QM3Y\nDfM3NFV8t70rBDRY2lxAqBFebvZXPkdp47k3OUKPfpoBx+8ldNZJ4hqkRm3R\nxGHo5SzJvR+o+34gI2KiVg1Y+ybw3UbM6G2VReY9tJNgCnx+/lTr1MeJZqw5\n0HU5OvkgcK60BH1vUdOXLvXxLSSgmBwCIR4HAJ/pYF/6SpdFLtaTGckTwojV\nYiLW2Mn/YX3gjUY4ooOoUTogHTggUKbaAQBsfjcJQKpvIJEljdz+fNvYlb/6\n5FA1NslPWMVj7iU+MAd9635oj5SkAjKEY5+nJis9z3blmQ3r6b4+gZlTIHFE\nj52N3SWPKY1sS2tGnRtFBVWkU19nfLWQ/9RLReDgptvYtYFU+P4cGeMR6fQh\nnEn3l55UvXHczQAjtv3L+/6deXgKaqkYd9fZ/fjsRJB48L8Gryf7m1t5qyLk\nwqTLWkxhW9CHKHScnIPru0cHfgAYBo03NPQyon6iiFg0nbSTUkDYYbjdjT3/\nElCYgdBfy5brJc39HwpKcK4XkMbqSx+zXOjUmpdQ60Jm+FKf5HUUgPsq9kAi\n3Vqb1HpmQAN+3P8G3is94C4qfagfYmnykqaD/r7pDIV2SDyeS8h1lh0bS+ps\nJP+p\r\n=lFsk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBee0btKIJzBBASMKZj8fhYhg8KDeMhJuJIfjYCXeuecAiEAnBGJHyc0eZuRrWCHGEMNhkntvYMb1Fgn9DGbPYkSPOI="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.0.2_1644420403014_0.9419591400604976"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.4.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.4.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"prepare":"webpack-cli -o bundle ./index.js --node-env production","build":"npm run prepare","presize":"npm run prepare","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","browser":"./bundle/main.js","exports":{".":"./index.js","./browser":"./bundle/main.js"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6","webpack-cli":"^4.9.2"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./bundle/main.js"}],"gitHead":"d511442f93820ed65d419bd7a2542a93d1faedaf","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.4.0","_nodeVersion":"17.5.0","_npmVersion":"8.4.1","dist":{"integrity":"sha512-YOfuyWa/Ee+PXbDm40j9WXyJrzQUynVbgn4Km643UYcWNcrSfRkKL0WaiUcxcIbkXcVTgNpDqSnPXntWXT75cw==","shasum":"2830a779b483e9723e20f26fa5278463c50599d8","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.4.0.tgz","fileCount":6,"unpackedSize":53945,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiFDPgACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpxKg/+PsFA/q3kBp6YELYYFvmW6TiS5Sk4GegthimlVCIL1di34og4\r\nQvEqGWZ4TaIe/wDB2z7S7DYUn2Wnln0WePvcpbrM+r/a4x8IxlmJnYmfM/jU\r\nE37dfmhPrKNNRtaML2qjBiOgVANG7D1keDf1lV0QYFsiAsyYHra8OGClAc++\r\nrohZexeaKTrxbK1rBI3F6G4XBJjjUJAojwZMFeq0uCtGnxLTqJqH5hxTf8BX\r\nsHOjycqFmmq3LcYba1ksy+RsFnSkXKeo+jhu8DZqycZ1ZaZL5TDN4vllxqAm\r\nqLd1UklI2ZNyy8y4zFCyRFy79J5xjhufZvGUFMM0/DT43Kd6kGaHXY3I+EVX\r\nVCCE/g/2s7QdzhnTgCFFJ/m41nYgBeSnXQZVmAjMCXhDVrmInGCmylQaf2ip\r\nF+jUcD5o/StVNOimyaeK/h37tRE1qZ5ykvW52P6ZSgWmfQ0fx9X+RfGz+zmF\r\nyU21h2XsdWzDtq4ae8IRqiHQcADAdJyhSuHDkSV6dFWrVcCbN+DVSUkBmF4c\r\nu6czl6Hdx+GbtsPrurxFMX6sUgAxvwRzKV+a5UaJhCkwolGaktjmotukju/8\r\nz/hOA/2T28MPjH2DChyoTgzH2kAynJeTxgMPG0l3GzwjmZB3QDLye47FROGQ\r\nm+bRVEMeOT+rfyQxZIkpEfX5//1n6QWW42U=\r\n=qMBa\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDyi1C12pqig2D67vuNeQOTKA9UZL7xWiOzwn0S7jp55AiBjJl/y1HXjmu5H14UiXcNgeF81AegXsZme8xcR76mjdw=="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.4.0_1645491168225_0.9488434959764496"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.4.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.4.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"prepare":"webpack-cli -o bundle ./index.js --node-env production","build":"npm run prepare","presize":"npm run prepare","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","browser":"./bundle/main.js","exports":{".":"./index.js","./browser":"./bundle/main.js"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6","webpack-cli":"^4.9.2"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./bundle/main.js"}],"gitHead":"2be1d2436218360dbf4c673088323b88840bcd24","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.4.1","_nodeVersion":"17.6.0","_npmVersion":"8.5.1","dist":{"integrity":"sha512-NCD7/WRlFmADccuHjsRUYqdluYBr//n/O0fesCb/n52FoGcgKh8o4Dpm7YIbZwVcDs8rPBQbCZLmWWsp6m+xGQ==","shasum":"afe07e885ef0cd5bf99f62f4fa7545d48746d779","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.4.1.tgz","fileCount":6,"unpackedSize":53924,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiIuojACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqBZRAAhyUAPJaxYoNKmqdn+CwAO9IzEO6Wz/0qHWbLH5axvUlnavJ2\r\nAUugfpiGtHZYuIpEzKlRk67E3VdMMQqAP9iabJcn7VpbSJ3STZ8W02QZaeO2\r\n5Yq7D6pjULLkMgBLFNMQefsxh/DCchVuWS/cAlMN3TNqjbFMXxHgW9wqRDAJ\r\napoKT5y4VNTSrGj2o28RDbnihsgQq/c0lovOS4OGw1XPE4tRr/NygRvnGr98\r\n6oN9SbYdjcf17v3HCz69m9wx5ZcyIQxP3E0BwJVt3S2BjPps1Qz3Ha3+hIn0\r\nYF+cP9uPUJt3KPg9ckdsL6kFIEtuKN0sFeU4ytf54JLt7yOKH9puJOfMdLiB\r\nmfsLobDC0410vT/+4tzYDCNzY1XbLSooYgT4VqvY/nDXrKhAqw0VU4aG6MVq\r\nM6xAR/oGw55mNXNQEBsWdmogpYmgnoKLqEcEUzkbm7xlURhh6vLAHKwKDu1p\r\nvhtWBj9s8yDcf+Iq3nIA5hc+FaZu+ELG/HzS5069kaa2lrKpmoqCKrAN3ahd\r\nEVFpopBRPAL5FmILerQIXpOj+ZtK7kbVkT9DhZdY6WokYJ9aDztujDeNfF01\r\nc4X75le73wKeYNCAcfuDcnBEtlQI+AsGmLxKPZY4EMOgJqqUR6OHArHzpycS\r\nl1RpDoJxl7oacw2452XcGSQWcQgMqzFZ9AU=\r\n=hTfC\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIB3FBRc28gKaPnzxhz1dJ9/fOwOPi1CSBAm+vDdR5mmHAiEAiPSN4JhHXVOU7jc5zEGMhGDYEINlX5S4iiJJVinBYt0="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.4.1_1646455331417_0.017315440199106913"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.4.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.4.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"prepare":"webpack-cli -o bundle ./index.js --node-env production","build":"npm run prepare","presize":"npm run prepare","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","browser":"./bundle/main.js","exports":{".":"./index.js","./browser":"./bundle/main.js"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6","webpack-cli":"^4.9.2"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./bundle/main.js"}],"gitHead":"04765f85a1e480c14b9928f2a40c4713ff8d611b","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.4.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-Xs3+hFPDSKQmL05Gs6NhvAADol1u9TmLoNoE03ZjszX6a5iYIO3rPUM4jIjoBUJeTaWEBMozjjmV70gvdRfIdw==","shasum":"92f7b5afe82759f51b216a96fae3bc1828df9712","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.4.2.tgz","fileCount":6,"unpackedSize":54005,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKNKuACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmotlxAAj0GlPZtQJGDWkmef3hC90LJJa71eU0uxGgROkEP+L7QWW5Fr\r\nfH+wN2isE0v3H3S35yp2CwWIyfqJs/9XX6TalDTbGsox5tyLGCwccJG0g8J2\r\nsXpJbPbxwLEVC5GQXtTcbvYy9zDVS2hLANihfzyZtg7l+bLG8Psb8oxb4oaW\r\n4+JkW1eiMPWUn7zuB6vULrno2wADA2WjTpGcKpdgB6Zui99rivRsU+NAb/q1\r\nGKtavaMMCUbYP4ACZ4UAZFrgFYi5EYsQyPXnaIesMxD+u48XAXNwbi5Lgd6V\r\nFyT7BJBbNRDNJq8sWjTqCjRPzgvSJQUw/gLCHRyugKDBTnArqHW6te826PIE\r\nW7I7RnuexbTxjBYQB1yJx+rBWaJKaZgG8tvX6zvyDIdMeq1JD1/TjKfDwE6z\r\nzEZglQw48gzKLgpcfU0x9byu8sRYrTmv/ylBdTTHrNr2NykzQKToebHxqtV0\r\nWj/hKDWtvdz220SeNXI0tKxNTtMlxi3AH0U5J1WC+BIhFJAkWq6lPbOGoUp2\r\nLZVwWDg/AgDyNKGN6am7ibM6GfFbSAaAvtOWEIpbjsjzbzxswW7SAiojYBoC\r\nCyEdFVQ7VDt4HPVApvRgpmZOeVkSVrpBSPVHfKxPNqpmo1ywqk2kTGBMA5+l\r\ndrSGkUkGugmhuXVUssTNauVDCto6lLwUzhE=\r\n=jP8A\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDixr+/umAXLj6trvoLPcTGrJwAu0++OXmFzBKimLGQ9wIgX+opM6jw4OB4FtFccw0Ezy2nK+Jeny/u9C/7B3CEXIM="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.4.2_1646842542209_0.48780490214664574"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.4.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.4.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"prepare":"webpack-cli -o bundle ./index.js --node-env production","build":"npm run prepare","presize":"npm run prepare","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","browser":"./bundle/main.js","exports":{".":"./index.js","./browser":"./bundle/main.js"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6","webpack-cli":"^4.9.2"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./bundle/main.js"}],"gitHead":"00449b331aac094d7a2aedab78b45ac354f17245","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.4.3","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-kuOtCBL+fxym0asLazBsj4mEmt4kwiLV6KTGYdAO9jjXVkx5svj3uMd3j/y88YONegeFAOETN8u6XPb8cw/mIw==","shasum":"b28a09754515ca5c6efcf1a5c995c2a52c40ac20","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.4.3.tgz","fileCount":6,"unpackedSize":59000,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKlBSACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmpe0g//eXE4RDxXiX811SDTkN1Q24IH2z21byhiQUvWUXFJyAe/hKya\r\nRB1zDZ2k0hboePrV4YjnoQr/ZyC4LAAdg+E7V5lg7PgnOt+FtKiMKaaoDkGm\r\n9MPGu2xD+Kxua3PbA3WoJLOp+7wqFu7JDhaVeu4FmzK0xO32QlidysHVMRvr\r\ne/ncoZ9iEbX8sN3rS6oIvHOONNmVM04vdKv99k5q24eA2BW6bxD52atfU9ip\r\nmISZ7kCf6dl4sXsPFqOXarCnFO7CjKRXH0SzH6bVKQVOWicyvzkPWv06WcSz\r\nZcwXpBO6Om8bzwcEKgpCaasLfHJHksd7JtdkScaQ4My/x5InnXVL+GcOSXWT\r\nv992Fjk5C7P0X55GvU/Rf+5ZOBwd9e+1vj8lMX4ONgN1rh2T74+Bqt39NwAT\r\nAMh4lPvgUo3gWbpgAjEpKkyhtzosYJVTlSrAwqPi0Glu1Jz1hMN42ACPGucE\r\nKaRPUDFujVAVSWtY4OurasnKE3TG5Y0pmehlYVrEpq/gIpsPmgDAkZ5Erqtl\r\nFo4rsXf1ezJma056cQ/qoW9Igt/3hEjpyRPpXaR81ARK1M7So7CbZQUdTmKd\r\nfTBFGEaUqaYEoIUINiJqHMb6Nyz6MJ7E/0PX1lQoxqXIVGgdzy+lteELI1+O\r\nSCZTzp6ReNLGKLAaFuOvwwsssIp+Tbnd4WE=\r\n=1i7n\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDojhZmiSm7ygupU/R/uull8RV5oOWMQKuERVJZF6vMhgIgNx+B1rVpp3tO/ZOAGGEplIMpvz9Gv1FFpYX01ST3f88="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.4.3_1646940242150_0.5160291687367282"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.4.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.4.4","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"prepare":"webpack-cli -o bundle ./index.js --node-env production","build":"npm run prepare","presize":"npm run prepare","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","browser":"./bundle/main.js","exports":{".":"./index.js","./browser":"./bundle/main.js"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6","webpack-cli":"^4.9.2"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./bundle/main.js"}],"gitHead":"aaf23eda3027fcc1bee8739b320a8cdaf404c14b","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.4.4","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-2XbUJmlpIbmc9JvNNmtLzHlF31srxoDxuiQiwBHic7RZyHyltbTdzoO6maRqpdEhOOG5GD80EXvzAU0wR15ccg==","shasum":"a3dabc394ec07e2285af52fd24d0d74b3ac71c29","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.4.4.tgz","fileCount":6,"unpackedSize":54128,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKlDQACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoMOA//QI37Ul7S3x/UcCuo6cbKvdpEiRpdQA9hD9zYak0Iv8GhdNMV\r\noj7oo8K4pAfkoODrLJzDPJoNAq975YetOYxcjiMP3rIt74AUYsj9jDa7iAQI\r\nj31ozpcCd3PvNaTz0S29x0USsamydM7c6E8PfrEg/5qiqRp/Omlf6aVvG7ws\r\n4Z/ZWh/TL8BKJq6oafjPzA7WbOP60JwLk5cpsH6zwFk34mniNSCsyOh8of/q\r\nrEtS187ieMPK88ETYIlKJ7de2lm80OeQgH9RdMZE5R+RdInf5ZJnr7bx2cza\r\n5KrDJgmS9pAP95F75X+jfIlQNaIB/AgLJXvDQLuyJ/DBQ10Bfjk0ZedrUkQI\r\n/R3XAXEqihucQuOHXHHps+Qjck5P9PAQgTYFRGmsnNhjg8xdcn+UsSU1pMMD\r\nevPpklmq2jnZv4a8NRGXDCjGcgAUrkujbHHlh9u+fRtzS7ztphPSnnafEukc\r\nli/HIXtt6zuPnFDOh6aB5EYwKwQPzsXcmCNuxgDDuOFgBFYEmmHoa9PU7aM3\r\n0WRBD+tpypfj46ByAl8Spv9m9U8/3Du2sInI+ZhrLAxtbhA9NVjt1rytOWP1\r\nECFkupliIJOQ9R9RUgMQPmJ4HDtU0mAZIoBDHfPmfHAFwa4ftIurYKPBhRNn\r\n0N4r3YEDoaxH6f3c0GwyKtcdcoi8eBEHMW4=\r\n=q/h3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD8DqSCj9iaxTZIKGC68GTncJz4BE3iia55jvhQkrmx0wIgdTWm/oGYZilpv62UqHjF1xASQJajDvg0vl8ag/npaDM="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.4.4_1646940367866_0.8649527812271489"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.3.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.3.2","publishConfig":{"tag":"v7.3-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argument.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `disposeAfter` The same as `dispose`, but called _after_ the entry is\n  completely removed and the cache is once again in a clean state.\n\n    It is safe to add an item right back into the cache at this point.\n    However, note that it is _very_ easy to inadvertently create infinite\n    recursion in this way.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n    Returns the cache object.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n    Returns `true` if the key was deleted, `false` otherwise.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"a20078b4a6b13cfa88f64e7697aac2cd1e80bc23","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.3.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-W3jeormhox/OUUGWDTXj2+1ks9YAZNkzyXi/4v9P2nzQGlD+WL/dX7yUE6/ZZp64A7sr8zQAkP0AfPxJ6bDJ0w==","shasum":"2c02862058d222d98caea16a091acbf926e36e5f","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.3.2.tgz","fileCount":4,"unpackedSize":36384,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKlJaACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr+ixAAh9y4z3cvEYxmwlnQ4AnxBCSwJgMGQONUPRV+W9+9kC5ee+Hm\r\nyL+zaiSO2pbr0ErhLtQMezNcNzA5ZXnb77uqCZxX7eXdbwARFk9KOVs6aaxO\r\n85X7ttBa9RR5xRKVRl5VibumiPfXT3SqK9bQb3FiJp8ht1N9rKP8gMxX2dgu\r\njktou0kL7RjG7xHbq4KyN/r/lOBdDLLCO8874X+I3dJWtZKMA+TjBTYl4ix7\r\n/E1+qTdBl3r3wie68xjraVN6YlU29k2loWrwoIH0Hj15DS/ujPU+HwANyk+2\r\na0SlUNWnH2s3Dftx1Ewveaj7+jaspVsGmiw6BNJmdnf6cQ7NMbbCgmDVJAem\r\nVdgyNz0cKze0ilz8q/tZ5G7RSP8YdiZEMNgL9AxkgwKlVscRkHM5JU312vNu\r\na/I9yf5H2H1fAzYCWclih7QbSJ3RY4BBDKm6zoU9bQSH2tswsYeXpN0iuzJ2\r\ngJM78GyRJau0Ty9zZRGuP7k72dvVMZG+qRGJUFgpgqIdz+zjSCl2sTOGzqm0\r\nrmRVasL0pVuHmoDO3wbwWP6OiQ7ySCpGJqgZkDyKyafDWhGgX+pZhaAR1rWG\r\nuNNVOmWO4E//rq4GQHdi2XTrRtM+OdXAUj2+gZ1uzcsV0W3Qvh/Dz+an1YDK\r\nmlGedXTpVPlNBvWqz1eBOw5h0UTLlA1jxKg=\r\n=TPgp\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFU96Qef4Hxn6Tiw4udcIC15W5RGfBuORMec9TCq0DTsAiEA00lrqEfHEd0T7PYAlg5XMsnUXUE7dLURgL4MfopyQoI="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.3.2_1646940762400_0.03571872113995811"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.2.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.2.2","publishConfig":{"tag":"v7.2-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"5594005ab0011fe9ebbebb943626a600c659c52c","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.2.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-zPNrJgZUeynYdtzoMZEMuwZjoSnyp5+kVkwo0X4UHAO7qCgn5v0bkXTYyzI7k3nFXDKVkhlXs8Smt6aMPFbCxg==","shasum":"f9692a86d9316588110b45de0f9bea1a868f34a8","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.2.2.tgz","fileCount":4,"unpackedSize":34732,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKlKEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqEsQ//QGrGHUSGuS6irR4UzcDgc28etvPOg2a/aujgPBuAUtnawHFu\r\nGOwSZLRw7em88EWoKetXvejxuWQ6gcAGXCIFHlPNmXOgAyxiXRH9B9M9pfuz\r\nULNVz6IRuDRDkUMm3zWbqdPS8uyN29N+ebxCs3UiwhjMB9zFs8+sRn2X4Crg\r\n6D60XRz0atIfuh9SGPXrDWkPKULOXyMsKVoxtYNWyZXdGzRj2MyGWCxCPoIu\r\nEO9GVxyRUUxvDIAPtJ+C9WNexq+/My7QyvgoPDvak9ZGWWf3yEAreDYcWce3\r\n2oLRsFdJoJH9eUcmUgLX7ulqSWDwh0d9Zw3NWfXul0qXAEwNaR2Z2Wp2oNfT\r\n9NvOBuM+aLlWow2kni7KGsDN2G85qbHbkvVoDAPd5BXKTxZLS05O62UEvOQl\r\nP8ICRok7bSY4NOYYXZyfMT0QfGg66LngfD03SJb4FrbYteyk9FhQQTgTGLcT\r\nRfomJIP642ugk6CvLOqahy/We409nVUoFlCU1QIw/OQKXVdTZ7s6HtiUMgmU\r\nSsNCk687RypQZqwCrwNNDolJizhXS1N2SsuI9JBJ8OgN6jHA5Cln9b0PU4O6\r\n9XHlXHQc/kAs0LpZnGcE7mupsKkX/m4qCPF61l2FWz4ADoQuzYfmy7gsbdIY\r\nzDZyowZC2thskQSQWbYrhpCY3AqIePsVCXk=\r\n=fgA2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIB3IBy6uOYr751Gxev01SFjj79iw7fhQMVirGQsg7Kp9AiBw+46HDm7grtn5vpo7iEO7u5x2i2fU7NHu27Uj12xK/w=="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.2.2_1646940804670_0.20291375813945156"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.1.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.1.2","publishConfig":{"tag":"v7.1-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  stored in the cache.\n\n    It is called *after* the item has been fully removed from the cache, so\n    if you want to put it right back in, that is safe to do.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"440baeca180e03581e50c37ae873fa862d73a197","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.1.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-u4Lv1LM66bMGCi8WQUURP7ORjC0JNlw0jrJZr/0prh4SOcTD68sZSECgJ2xtjM/PO0/Y5NUGAP43EeCaOByCAA==","shasum":"ab90020ba299d9d140cf97570958ec67eb3f2797","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.1.2.tgz","fileCount":4,"unpackedSize":33937,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKlKqACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmogmw/9EMq7Gziii7rv2sLlAZwcijllKU+SPwkUlIKGwnb8kZTILEjp\r\nwE8jI6FWqCWGa0g4Mr7KEsEOtHbLGZ7QIfjs0iDHzvNsuuIXplfL4JduHTv6\r\n/pETfmyNySuGPiUJyEN1kcxiuTSNXtO0SZ8RUJthH+EgpInpMzqMrV5zTtOA\r\nHlfBKuc8tCvOyZnRxyFWhCO5KaJ2RayJNp4UuaDa8MiJ2RMxOVrnG12HA89o\r\n4us8iW4M/M0HYWiR9Wlap/PKByYIz4XRxItgg6+xZyzSTY8T+OFxLNdK1VCA\r\nC8P/b0bhPLm3EP8WAJdU+8o8ZjadyRcwr9z8AoZmIA9UpNLu30uZ6ANV4hVX\r\n3P9wAONTML6QwLHLyDRo0ZHGlRSDnrSIiXfs4nPeBCsuw9dkfwpha6rkn8oS\r\nZNDELTxWgCCCGC0GXBBLOXTaGjxh1vBKo53m/7MsqC+uxNHgGPRjPKvp/Uao\r\ni1U/w6/DgmdyTfXNbJvtntuqD5PGRMQYp7Djxdn1cFgA1+eqiWZCV8Ugxjz+\r\nGrwfafV9L3w25rRMVq31FMUAqUqa3UBmHRowCdcllyP7EImk+HRQaqPCpqoC\r\nZifTsmqO9X4M8k7S0v8LIo0dhErn18lOdk7hiFbfUCR3cbT0CDYx1u9bJODW\r\nSVlNFtV+grXlQxquAdw7a+30xX49HWdIBgw=\r\n=jaIx\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHdFdPYNa0ihT7hvbvABQbiMZjd2o1NAb7d/ylmO7+t2AiBY601rZ6gYrBZWbPzusNGmYR3cIE2vDFUAZEGkKDkiMw=="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.1.2_1646940841899_0.6806455451382682"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.0.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.0.3","publishConfig":{"tag":"v7.0-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed, and MAY\n  // live in the cache, contributing to its LRU max, long after they\n  // have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  stored in the cache.\n\n    It is called *after* the item has been fully removed from the cache, so\n    if you want to put it right back in, that is safe to do.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed, and MAY live in the\n  cache, contributing to its LRU max, long after they have expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  pre-emptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.ttl`, `cache.allowStale`, etc.\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n### Internal Methods and Properties\n\nDo not use or rely on these.  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\nDo not report bugs that stem from using these properties.  They will be\nignored.\n\n* `setKeyIndex()` Assign an index to a given key.\n* `getKeyIndex()` Get the index for a given key.\n* `deleteKeyIndex()` Remove the index for a given key.\n* `getDisposeData()` Get the data to pass to a `dispose()` call.\n* `callDispose()` Actually call the `dispose()` function.\n* `onSet()` Called to assign data when `set()` is called.\n* `evict()` Delete the least recently used item.\n* `onDelete()` Perform actions required for deleting an entry.\n* `isStale()` Check if an item is stale, by index.\n* `list` The internal linked list of indexes defining recency.\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do that,\n   and use a cache such as [lru-fast](https://npmjs.com/package/lru-fast)\n   which uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys.\n3. If you know that the types of your keys will be long strings, strings\n   that look like floats, `null`, objects, or some mix of types, then this\n   library will work well for you.\n4. Do not use a `dispose` function, size tracking, or ttl behavior, unless\n   absolutely needed.  These features are convenient, and necessary in some\n   use cases, and every attempt has been made to make the performance\n   impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\n### Specific API Changes\n\nFor the most part, the feature set has been maintained as much as possible.\n\nHowever, some other cleanup and refactoring changes were made in v7 as\nwell.\n\n* The `set()`, `get()`, and `has()` functions take options objects\n  instead of positional booleans/integers for optional parameters.\n* `size` can be set explicitly on `set()`.\n* `cache.length` was renamed to the more fitting `cache.size`.\n* Option name deprecations:\n  * `stale` -> `allowStale`\n  * `length` -> `sizeCalculation`\n  * `maxAge` -> `ttl`\n* The objects used by `cache.load()` and `cache.dump()` are incompatible\n  with previous versions.\n","readmeFilename":"README.md","gitHead":"0d515a2c47dbbbf8f5663d1488c20ac2b4221783","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.0.3","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-Fq6gvppbqhKZd/qpePv56fQNmVj9ZwU8+qEo/8k5LtJuJVvRW1ZdWnFN9LePFJnoJ9gUSjhT+CsxNp3wwQOdEw==","shasum":"7f419682ad66841da4e87b4e3486fe80836f34a2","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.0.3.tgz","fileCount":4,"unpackedSize":29495,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKlLVACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoWvxAAn3VSYnB0rU/zRkx7YU+Gd8FGIzenGqdIcfBZ/GD6NpOgoZ8H\r\nWZ4yfy4rojdt0RSaWj2sR7k11et2G0E1Xu+GxTY4WO/iv3U1ALHg7//YUs+M\r\n+MicGKHPhJpgyIfj5K7HsBUSnXkH8yHzwEdXikCTZD/d/0hTfD8vA8nIqrJI\r\npgaGWLlI7Zgo03ygjuC+ue9ZN361dgjuvNzutsypVjtL011N0qb2coOwXns8\r\nkUzdpkZ91Uj3CJCOcfCG7B+MvRF+1vOwKrVtKTnrhPA3TYeFKsl+BI5+ID1d\r\n/9Rtk6nzH94sOBFvTKjwZWQq49LnUjJErU8m+pejFJrC8kC2Bme4ozmz0Y3F\r\nQNqWtIo1OOgBgyRTwmL3OCxv2aj/jRawYYiO4ZbBRAPL5hd6Pp2zqNrDsCvn\r\ngrYdSrv9Ok5/5vejmYimR+7czMO4hYEt9cI1AUJcsZ9n9/8otRUSRQxlcHxf\r\n9cby6OAQ2YmV9nmrVoQyDrTDbTk5OmM43esdqJmx6uXHl8YkCv9Jc5IKtkFL\r\nPwTG9t0MjhLDiSNcRhkazw951xBUyGwlGdoWYdUcGcjE3U9smsYmF9DjuPJl\r\n6URS2fnEFkmn3Q+StBj92SH6eiUcOCmpX0rxXAnhuIBN0MN3Zf1PVd52LcYo\r\n1IJ8F8YdudXbRvEy82bbDkiNN2Jg6iaf1oM=\r\n=0wRN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA/0Gy+XzxRtiWoZdfiyY9k9LhGcLxQb3+/ak9EVN3h+AiBTxVU9BxmmNzQysX+z2kj+p1fiB/bpoA6sieREhJt6KA=="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.0.3_1646940885672_0.29784891373906497"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.5.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.5.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"6406220fae5ca7bea5c083b121f53a526edf8348","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.5.0","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-8neUvdgNtubJ+VNNqrqOLjUoIlN+NRPFtv1Vne2rQ4uPCxhp0W4TlqntzTLnVVezGXcSSdXTrKCTYooEQA7X6g==","shasum":"5e14318d64e6f180a5cf3b9b955b2e89376c0efe","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.5.0.tgz","fileCount":4,"unpackedSize":38285,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiLq8zACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmrhsg/9EEMNAZj08N2rPGh6cgjguBM9K+re0kAEK+1QLODj8EP9O8ra\r\ns9sKmXOSSzvPTySYLoR9Q83Yp/SJjK+cwWf3HNyb2TXsoll9La9d8ME0WRmt\r\nU0i0/1PnWdB9lsAS/wZB0WPmPES75a+nxQEXqBYpCATs7/WDBuFgCwDmi6zk\r\nmm7IGvGV+mjdfWbj/I1rUwjnLWokXNO66cOVeW/SPO8kE9ks8XosXCreA0uU\r\nDkscuC1t75hz/TOsKFZyNXOxV4/QuNBcV3IlcFEV3ER1Uc0ewA3SHQSG292m\r\na3cRQYNk5D7cUK/BTYMYXpyMjh2mt2Rly3StIjGLTsNb1nZ9vEwvGX0u83Jq\r\nmWlt3pmBSgLNHsKdcGcsQbP8MWeUQlwsKGgS5/y0yiuSTNKM3Jx17jn/wx/Z\r\nFeS80USBt12Ug8WCgpODppYQw93YsMqZyVw4NsT1YVsX5PkLX7Wdn9ouxg+U\r\nRHtUnF7sOImVC798iCxpC9KKB6mW3bHl/Hu3PeZJO1u5V6PDz8axVXcUuYtY\r\n51govwxBk07VbG460lhocEoYFUWRK/DIOApWCgqqcDfT+mkXe5h1eYwne8c4\r\ntXdmZh9+NqzrYbd6Ba5EP1R9tidO/nJH1z5XRZKoAAQ532oJkNW+2xIf0rbM\r\nicnOJt6JRtNp1w+qdlOS3l2puNBPALPaisw=\r\n=RUfu\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIB5geOdAQwU3w3FoOdrrdXp81JnBjo5/PN1MGs/CT9+iAiEAsXejHl8OojWGQpozHUy+/cX71YxnCNmqPxMut4M/jN8="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.5.0_1647226674916_0.5975480216807405"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.5.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.5.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"e608eb8341df51e128e1a2526682901e38539b07","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.5.1","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-q1TS8IqKvcg3aScamKCHpepSrHF537Ww7nHahBOxhDu9D2YoBXAsj/7uFdZFj1xJr9LmyeJ62AdyofCHafUbIA==","shasum":"660a134c2c3c015aa453b03df55d2a9f0c216a0f","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.5.1.tgz","fileCount":4,"unpackedSize":38262,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiL35gACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrXog/+M8z8izDW4APbU9wr0KDMR8y1apoWOKtoCfg72ODUVkkzpg8E\r\nlxlsyQb+T5d05AaVOUWehAHfT3kRr5SBMMCMNF0ym+QvUddphEUpyQoPZhOZ\r\njznArAi5sX4JMmXslXFED4ZsVbZTVjlj2KezMCgaKDRJn8njTvDxhe098ZKe\r\njw9EweaRziteEc7fncQZOnW+XxKvBcNGUc7Ra8nhtMt6AVEpHdDjgSQBQtUo\r\n0c4QfJ6hgkDBcqHd5+hB8xlWn6hORDXxsJpg3fnnup6xccqRlVqqWOk4vrAZ\r\nSC6N5906uOHCRDuckzWcJmUTTJBaT6vEm3c2i0eljqnSYKmDwHl3KaSD1a/b\r\ntOwItHLyNiYQesVIZNT2B5vz49UUfTHO38gV9w8AnrFZsFPWwG1vfQsJ8UiD\r\nWnUc6dLyLA7De7CNDVylkuAF5sSdTixt6X8VQsSrHx2Aj4EYUCIbfSo5B4n5\r\nhqtFaVV+GkoNmVaXlD4+Nr7VcKXdRjxAm1YJ4Dgi3D17SHbzRmhUDp5BN0Sd\r\nMWNlvTUpV0vUQKj5a/fnYV0tr718kBQNQFwD6Ki9wFj+3yhUMvCb/LVMT0js\r\n5MemsbmkxFsZkSDHup1aIhtLo+EeRrJ1gsylZo/ErQdLcJEZmYIP74V1YlAw\r\nkiFdoBTa4XfLyGXiiDHLne8CMXRy7LBUFak=\r\n=aBR4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDlXxwXJ6eEI0sNmi9zxHMy7dxOBEazeYd2AnVGdWWOSQIgNNyUm+2e5eS8OgC7oY4SiH4ZiaoPllwYHWdmAjpfVA0="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.5.1_1647279712764_0.7234295714520351"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.6.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.6.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.3","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"243114d7d4a72b81b40b8d546e457396a321cf10","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.6.0","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-zjOf6cyMI7rcN+5MtLsT4GnDjc6D9XHi8kYcsfXTqWC+yLdSiU3/jtEPX9wZE77+XLtnmdIWu3+291hkizfH+Q==","shasum":"33c9a9815ce6e4c0e2d5d151f6a28400770e7ce0","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.6.0.tgz","fileCount":4,"unpackedSize":46344,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiMrIxACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo3Pg/5AO5g61kLtzMlwOgEdM3STM3GYap6rbh0rDHyVnLtOqRcX0vS\r\nlmbfrmGOiVtikUvbPX5yzalqDttMKYcWIDaFUtAJnk9nFOkOB1vL+e/MiZsy\r\nJVj9kFbWn4DWwmvnEgZU4bwb3HiFDuyNJ2EmArnhFNImyi3L9CJBvnsh/fRl\r\nqsd4XwST5v5SoH4pUXcJZtTRUqhhauzZmi8ZkHROSz4sMNPc0sKf6vjxqi3/\r\nbIVwPlEh7MiCVHZF4qfZ/6tRepHrphXW89F8L+odsp6KsQmkqIbrhYAAJURd\r\nPdbpTne9ZG0A4FVHU4skLCtJamRCgqZghLAUa8Rd1YYTUMWCf8HNOKlbHde/\r\nucpQxPZGHibCAZqP/ngw8BKm1ABvbADaKZb/IFIOOBTmA2YQ95kpvrxYPKTB\r\nEYgr98AynMMZCZSNsMi7z9oikb1570KGZwT6vG2Q5NdHwC12L1RoeLEtR39P\r\nuRVINjMNcTYFYrBEUVJ7pWx6w/IXaK1oyuN/7VPhYaY8+0ro8L/8s02CR1aN\r\nuJ4qcD3aV6p5kBEhhmpJwoTupkCBODL5WPnnRJUkY6jxJl9bLhHH/dgQBZC2\r\nc834C1ezZiA6fIJww4YVrfZfbgJ1h6YrW/1SAZSJbmZ+xEAgdfrfXI8g5bmG\r\nKrm+nNxI7kyFC1bcpd58H5877mwnBikxeWo=\r\n=sHbw\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBPdgm5mEeOiNZ2d3yql2l6cwS4GAEVJ6Ifdg9rTlRZGAiEAt1GOQoW3JuMcbFtuUno141aSiNnqik6ysY7a3iwlQqI="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.6.0_1647489585674_0.2590322162594001"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.7.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.7.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.3","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"74edff9a114115b1c93364f73e6e49ec4d8f2d9b","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.7.0","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-3W9Irr9YR2ZHJbfRr/hj8VtzqH7DugwWyHONyDByP6PLS/YJV7GTX5dDYS+qFe/LkVfnCjtk6vkVsxxKGol6jQ==","shasum":"8ce6eeb1b553660a99edb3ff832cecceaeeece17","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.7.0.tgz","fileCount":4,"unpackedSize":49057,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiM8ioACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqBqQ/+JvAkFERuTs1HsvKyU7JcMC1iGzxU8SNc5Q7T6lhyljTeCM4S\r\ntauA5mx8j2aEoCK73JcK5kZarbmlQM3QXiVn9wZCpPce/JpJ2cD6SL4J/1S5\r\nH0oohyTwXD/BRWG04Osz11r5KOnmtPpJGoZvU9zwhcpr1C3pUbWZRLXCXvh2\r\n7mgGevufOYMDZ5XQWgmOjYFDPpnxhqbtIhpHFjMYpI6Lz8Pwv0sDvYs5Jw9c\r\nptOnkB75fCPLZWdco+fNKlHRqxsxTYFR9a7hwCAKiTztlmOQ0X2UL6/HTnDx\r\n8d4xAMLEd427tyW5asEGSHGCB5bqhtahhyRVbDXIFdeS+tAuhkj2Qk0aqEXF\r\njdXsEvCLMsnVOaLLeCWeay6HxpRaX6Ng2ESz4kMNOE+xCzTFQtt7yazbWBMF\r\nm3HthPAVr+hNML9gERFK0g/KgSncxSOXFgfNYa1wxqyhHObhbMO45QOYBPjS\r\nKcZhRgoxSILx+C4sfLnSj2OL9flktxcQc/WGMIwNj4J2MVhO0jnGRRFV13ic\r\nSwrGBQpOLqte45M3dpxMrSDKJYnjNuRra0xzwh8qiNk4tVRsFOiznOKaB3nC\r\ncertf+hT8/lLspHQzL2D9h8OV35umergVYi6XklkTnQcTI51LD4L4EIDYB4A\r\n+YNKgJMWWfygPuMBbJWqXl97WP3CYLBroSk=\r\n=Rbfm\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDMPxXu2KF6PQU9f2QqsrA0jAZ54nZeRX1DwniMxOwXiAIgFVCnDu0BneDGtUa33BkCl74p/aYynZlpMVnOqRhWxVg="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.7.0_1647560872353_0.846644611126973"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.7.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.7.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.3","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"b0e4020b7b2c619ba48a61758afa2c17fb8b7cd1","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.7.1","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-cRffBiTW8s73eH4aTXqBcTLU0xQnwGV3/imttRHGWCrbergmnK4D6JXQd8qin5z43HnDwRI+o7mVW0LEB+tpAw==","shasum":"03d2846b1ad2dcc7931a9340b8711d9798fcb0c6","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.7.1.tgz","fileCount":4,"unpackedSize":49059,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiM/W4ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp2Iw/+OgqB4tbw+vI45E3QBv9H8KyL69oVYkrkRGm11GVdtxWqQyrL\r\nln3NJk0MyUfr8RWMyHfZWLTJHbx1MDwbmKCvQ+YpOmRKsPnDjgF4r0A95r26\r\n6Hl44XoD+JLG1+3o5BbGBTZ4fuXnIpgzC1s7btXGKhkgMPDD4iVNLDVN/5xM\r\nPcxFD8dq0LZHRmoLIZ0kyRPbSm97Nc1nbVGx/7FQDVCrswiYrquflVIXsLkz\r\n1HXLrdgS8QHlh48wrD7OqEEb3GQSjVGhlFosZgSiRigxhIenR+SWTtHdUiBe\r\nCxokmRmS3nc3dAimDMinKMllpehcweRrIQi1D5WvWC45C+e9ip327ITh2ZGs\r\n5pvObzawKWjj5C1Qq/kqZhRbBLPGcLv17gTQzgeZpeQZhHz9SkQ1S+4Gy1az\r\nHQpdCAbQRa9y1jIosJPLzG7Zn98fD2Tp9HFM8ZpuEPNuQNWvmL2+sV6RarT8\r\nzWJpVDjPRCzTHcVh79gwgTd37ZLl6gH76F1LrK4F5hQ2BJsl8iFcbCEbXJOO\r\nPCz3YIIYKwch3SWbaKeeU1Mh3ZMeC9hk4ce8A+lPTG2Fb7GiHxDV53TJdVmp\r\nScz2mD7RbjY0ET1h8s0YQgb3VvBa2WMOqQubaFo8lcmVcW9UH3DZZiv8jDtZ\r\nFLxpxrrPJJNTqtZqc9wGeDSrflOPQkn4/9s=\r\n=OpdD\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD7dcM+wp95issnZpHowi3I93PtADbRIA9kB1jyFTo/8gIgKzuPtlF2XzJ7B0Ww4QeoMrxgj98X7cs76gUc6+NK1ew="}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.7.1_1647572408611_0.19350637451252428"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.7.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.7.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"49b95f27ca3af929fc5fa7cbae36bbc1710663e9","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.7.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-WkdIOIF7HkfVHXxKLjhH6lyAxSFoSO5NZpZS9cH8Oe5rAI2ZDrVmIweDAZUHqIhl0zasQUprVVR8uv2yggYYvw==","shasum":"9a31f924b96e0e238c1f981bf3fcc2563aafb5f0","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.7.2.tgz","fileCount":4,"unpackedSize":49352,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiQ34mACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoLrw//VuOKH43cjufVfKKt4oTwp+rFfcX+J2jLR2oRE27tqXjIOVwh\r\nH4BpgT3hCYw5n9J06aYhsjSWw3VUKR8zM0eZ6oiICsHCVg/bxFmlhLxMGPe0\r\nfy+RvbAspKmRYCUY8wL2LV7j08azN8HLINGG16YMoLWcdWvm03AAZVO6S3qB\r\nK/9FVgxlrFBRx0t1NhsLY0aQSOy3OQWrH2RqNOYKTkGCeF2o2eG2fVbLlVDc\r\nVAsuqk1PN6JwRLoOuhK20LzFrKgQxwKLE4osfTn4aZ5uLv887DStrZE/6ivE\r\nzMlvQzRQHterVYMmHU6BpjD3CXCNKzM5m3RaUdQXZ/MpTG1/kdxeRmcPOXDA\r\n7RLOjzDbDEINVKohrYWZ+6NqlVPtAolUGbNHyD21DmBfb/QQNncXiRfZb22t\r\nOA9qyPDvBJJzMxlKDWcdMVKy70UJltd/kY5PXpkt2A8UWu6RkLtso2visN8O\r\nlKyiYXcAbZ3EmhK2ddHycf7p2VRnUcXsWSTZk/1R0i8MxciUO7refj/tcKL5\r\nbN4l2HqPiWS2H6ffd5C69yPDSn/jjBOW69YzrtYD+2DquHhvu5AQwdnnKeCW\r\n55+1Ivj3RKTr5Ds00622UsTARgdsTxfCh/PWFseEy/z/6GlDMLmUcc/YWE3u\r\nuhky+jsrZWD99BcJXXDdviQcc0HZAgXMS3I=\r\n=/mtB\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCtJtinjS0QhPunZHf0JDkSqvwvWtuGN7Vt8U5VkW9EkAIhANpJasD21WSIAtgVkbgk7bp8H37g5pD2w2tS+b/l5Zhe"}]},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.7.2_1648590374005_0.46460989436219746"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.7.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.7.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"96a05fe9433c42c66d8c885fac8789cfa250b743","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.7.3","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-WY9wjJNQt9+PZilnLbuFKM+SwDull9+6IAguOrarOMoOHTcJ9GnXSO11+Gw6c7xtDkBkthR57OZMtZKYr+1CEw==","shasum":"98cd19eef89ce6a4a3c4502c17c833888677c252","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.7.3.tgz","fileCount":4,"unpackedSize":49352,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIA9pErJMChD9ZiswMtRQCiD6QG1TpT2l/E74RMnkdp9zAiEAvwenukeUDHbWz1yKuqlrd/0FnYJAxljAkWCsyvuPkjM="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiRHTfACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqYHA//WFAOU39I0x6kno+sIyq0RV/U3SM2P8Ta2jZmsLrlxFo9q1cX\r\nBE8EIfZKjqY9eGqXVz6ozR5eZ5sL6pX8pXb4+/INlC9y47HUpw3xOeZT3lSB\r\nxuDNxJDnECBhzyZjRf4A2/MMGai9VpL2pCbhZKaITKgHhwBRajPZvy2MBtPn\r\nZqIR7lzoEAV3YuoTzgarQUT6UgXiXeQaRCmZ967D4ThehR8o5gZx2zPNDwq+\r\n9AtWMrTglyo2D8yFCKKwIkNG/NyuYNwBx/E8FlfpdaUvpy518TqQogWb4Hcy\r\n5E/4LBwv/1SiIwKqYnF/7mXmkMNT9nLbZmnt0t2AtuVS6QnX+0ZEVWaTNenT\r\nul3ZMuSW9CffZmBtNxaS542Sl5BytMHqGOiee2CuiusFzJDjIis7g/p1KGth\r\n3A7xXRWHIrSeGEuPAweZNBSH4QOCH2f6jOSPu794Dmypj0RwekQepEzc2dxd\r\n17tL4bXeHKcI9CJx3wKEzLUur/Rm4e2jJDhSXDlGgB5ApzmxmZ1r6OucSTKZ\r\nX3NCl/0rrxS+BuPxp45RQaEQYt8T0vjfMmlk8dTUPX2ldJRBko7eLPAmCLlz\r\neUhxfKbxLvZjG1wuITh+xEsapGw5YCu93M4kS24ur8+bcbPprAZiDPR+KOrA\r\nSOI7b26hKJ5kVhmAm1RT+e2OSiuUkUS09hQ=\r\n=6AHc\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.7.3_1648653534991_0.14582414592360093"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.8.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.8.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js"},"size-limit":[{"path":"./index.js"}],"gitHead":"3cca7d2bda98dae88a09d53b4aaafd4e589ef91a","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.8.0","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-AmXqneQZL3KZMIgBpaPTeI6pfwh+xQ2vutMsyqOu1TBdEXFZgpG/80wuJ531w2ZN7TI0/oc8CPxzh/DKQudZqg==","shasum":"649aaeb294a56297b5cbc5d70f198dcc5ebe5747","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.8.0.tgz","fileCount":4,"unpackedSize":50446,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCpwDIQMtrxToPSE7saBqejZX34MvFPHQOre7Gu/hiHiAIgCly/+IhX35a5RVRfsgB03xMw5+xTSDHrDDfdZt5CeqA="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiTz8LACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmop4xAAlQQMANM8yb5JlwbYhh3JzBKyrAs3vlEQa3nTaq7i3KicSD0v\r\nt70DQ5cAq+fWgnY4DnfB7bJW8wr9C8SETDRjIkjj9U27+Fuw+8MMQGmnGX6e\r\naU8ZWrqfL/L6X6mYo9e900jcd3HeArWm5lvyxxIrM0FpxxeUwWYHkP21o84Z\r\n9YNjKy4Mv6Tz3MCL/8kN58cL40QgAMNv4tah0yK3Cr5aBKF27xB+0quz+QzC\r\n/lGsvdBWYlVG7R2AiAcvz4KsEzSowPaw3Huh3skCW6jL0n6wDwiTEmuj+62Y\r\nS42cicyQqJosENlRUTAXgtNTJW8vnKxPLGhfDstTK+KCNfR8EhwTOYqUDQCM\r\n/3uP1l+qXEwAsD8zJc4aWUY4yIbg5ofF1+s9bGDUsx3ssGhkx/66mEjLa9nX\r\nhTyDku3eicuBsoFxuUYGNPltqeNn9PPtgJBpXQt/hWcvy6SWSPE/vsJrOan4\r\nOcVNoVA6xfMivvKYXWMtfO529YS3E9tLmRxQmBO4jGVuDTaYvgReEZMTqdfz\r\nHtg0ukq69t2zUXbQpQc5DS0UCo2vmQzADOVBe2tnyP/j1qEC3dm+OY4NDG7+\r\n0nu/1PNYLaa4Qdn26e3dpBFRtb3vdpGDh6sGRU/U3pbY0xycRvLiEWFG8Ili\r\nQaVeVuc5wbUvce4A3oogINsVQcM/5D36SIo=\r\n=YR0h\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.8.0_1649360651088_0.45077281608338127"},"_hasShrinkwrap":false,"deprecated":"Please update to latest patch version to fix memory leak https://github.com/isaacs/node-lru-cache/issues/227"},"7.8.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.8.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","heapdump":"^0.3.15","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"gitHead":"1e7e0f1bdcc82e73233fdf0535d104bd5a0386c5","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.8.1","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-E1v547OCgJvbvevfjgK9sNKIVXO96NnsTsFPBlg4ZxjhsJSODoH9lk8Bm0OxvHNm6Vm5Yqkl/1fErDxhYL8Skg==","shasum":"68ee3f4807a57d2ba185b7fd90827d5c21ce82bb","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.8.1.tgz","fileCount":4,"unpackedSize":50892,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDlCkz4/8R60vw5NgVZerHBTfwrdsOfr2FLMdX5wytvuwIhAJrygsw/vhP9dl9vZDbQ2jFpADk9v8qL0bmWrXN/rahj"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUdycACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoUCQ//cYSX58lpI3bx0Reej/67bMRA4D94Gbx5C4sx0CbXh/arQrz8\r\nOnT7LI2DgplpEJi7U86SLYdy7n87IoZkTEVdDIeGk41XZUpPXCUf85kW3sim\r\nFGN/fNPykfQyIS2nddNG2N72BsD2daZYmYAme8Qvf1EvBicxpm1OgwXfj0Ir\r\n6HCEpV7bAkJJhTeILRrDv/aWmjwB+XU8/GLd0QEtRSD9iCGk5y8NtaYcpwAW\r\ntGspllk045BdejxXLPF6XXtRoDn2ZsYhqBUiclcI1KNlyc6EPbWJdX0PepTS\r\nIJ1yKOyWzqU2m+47Q6OtWrXqUWdSLMrsD3nY5SUmBxy8qVHvc5k7xz+0nTku\r\nPDiDonVAxkSXRhtM1QHjRXFhxRV0trPVEvbLQxZfquq3VOQ5KXxvO4U/Zth2\r\ng2C6vyZVm0FJZCwbTm2Dn4mZN8rnZv/q7MZ3eG1Q2dQyS3YMYOt2DYmBzsXb\r\nqZdMIdHgTKE+NF3Zam9gi5gqnH4LWQIMaAAO1gzWdo1frZv8V8P+4hRuJGqM\r\nMGbsZTStvNdHJxCgenaLZECeNsOuedpolSbAqHS4NilWrjeZ+G3O3hNU5Rxn\r\n843wlxz3WA8ySayVE4Y3mA8NAYndMBHuz2qJolu96LcPq8M4QOEh4CyYBaJD\r\nrHGPQOwpL8PEfF0tHKJzf+7eYFEVlFKJpdE=\r\n=zQoH\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.8.1_1649532060382_0.7559077276959458"},"_hasShrinkwrap":false},"7.7.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.7.4","publishConfig":{"tag":"v7.7-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","heapdump":"^0.3.15","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n\n  max: 500, // <-- Technically optional, but see \"Storage Bounds Safety\" below\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n    At least one of `max`, `maxSize`, or `TTL` is required.  This must be a\n    positive integer if set.\n\n    **It is strongly recommended to set a `max` to prevent unbounded growth\n    of the cache.**  See \"Storage Bounds Safety\" below.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n    Optional, must be a positive integer if provided.  Required if other\n    size tracking features are used.\n\n    At least one of `max`, `maxSize`, or `TTL` is required.  This must be a\n    positive integer if set.\n\n    Even if size tracking is enabled, **it is strongly recommended to set a\n    `max` to prevent unbounded growth of the cache.**  See \"Storage Bounds\n    Safety\" below.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argument.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `fetchMethod` Function that is used to make background asynchronous\n  fetches.  Called with `fetchMethod(key, staleValue, { signal, options })`.\n  May return a Promise.\n\n    If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n    to `Promise.resolve(cache.get(key))`.\n\n    The `signal` object is an `AbortSignal`.  If at any time,\n    `signal.aborted` is set to `true`, then that means that the fetch\n    should be abandoned.  This may be passed along to async functions aware\n    of AbortController/AbortSignal behavior.\n\n    The `options` object is a union of the options that may be provided to\n    `set()` and `get()`.  If they are modified, then that will result in\n    modifying the settings to `cache.set()` when the value is resolved.\n    For example, a DNS cache may update the TTL based on the value returned\n    from a remote DNS server by changing `options.ttl` in the\n    `fetchMethod`.\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    The `dispose()` method is _not_ called for canceled calls to\n    `fetchMethod()`.  If you wish to handle evictions, overwrites, and\n    deletes of in-flight asynchronous fetches, you must use the\n    `AbortSignal` provided.\n\n    Optional, must be a function.\n\n* `disposeAfter` The same as `dispose`, but called _after_ the entry is\n  completely removed and the cache is once again in a clean state.\n\n    It is safe to add an item right back into the cache at this point.\n    However, note that it is _very_ easy to inadvertently create infinite\n    recursion in this way.\n\n    The `disposeAfter()` method is _not_ called for canceled calls to\n    `fetchMethod()`.  If you wish to handle evictions, overwrites, and\n    deletes of in-flight asynchronous fetches, you must use the\n    `AbortSignal` provided.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` or `disposeAfter`\n    options are set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    At least one of `max`, `maxSize`, or `TTL` is required.  This must be a\n    positive integer if set.\n\n    Even if ttl tracking is enabled, **it is strongly recommended to set a\n    `max` to prevent unbounded growth of the cache.**  See \"Storage Bounds\n    Safety\" below.\n\n    If ttl tracking is enabled, and `max` and `maxSize` are not set, and\n    `ttlAutopurge` is not set, then a warning will be emitted cautioning\n    about the potential for unbounded memory consumption.\n\n    Deprecated alias: `maxAge`\n\n* `noUpdateTTL` - Boolean flag to tell the cache to not update the TTL when\n  setting a new value for an existing key (ie, when updating a value rather\n  than inserting a new value).  Note that the TTL value is _always_ set\n  (if provided) when adding a new entry into the cache.\n\n    This may be passed as an option to `cache.set()`.\n\n    Boolean, default false.\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n    Returns the cache object.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `async fetch(key, { updateAgeOnGet, allowStale, size, sizeCalculation, ttl, noDisposeOnSet  } = {}) => Promise`\n\n    If the value is in the cache and not stale, then the returned Promise\n    resolves to the value.\n\n    If not in the cache, or beyond its TTL staleness, then\n    `fetchMethod(key, staleValue, options)` is called, and the value\n    returned will be added to the cache once resolved.\n\n    If called with `allowStale`, and an asynchronous fetch is currently in\n    progress to reload a stale value, then the former stale value will be\n    returned.\n\n    Multiple fetches for the same `key` will only call `fetchMethod` a\n    single time, and all will be resolved when the value is resolved, even\n    if different options are used.\n\n    If `fetchMethod` is not specified, then this is effectively an alias\n    for `Promise.resolve(cache.get(key))`.\n\n    When the fetch method resolves to a value, if the fetch has not been\n    aborted due to deletion, eviction, or being overwritten, then it is\n    added to the cache using the options provided.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n    Returns `true` if the key was deleted, `false` otherwise.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache, in order from most\n    recently used to least recently used.\n\n* `rkeys()`\n\n    Return a generator yielding the keys in the cache, in order from least\n    recently used to most recently used.\n\n* `values()`\n\n    Return a generator yielding the values in the cache, in order from most\n    recently used to least recently used.\n\n* `rvalues()`\n\n    Return a generator yielding the values in the cache, in order from\n    least recently used to most recently used.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs, in order from most\n    recently used to least recently used.\n\n* `rentries()`\n\n    Return a generator yielding `[key, value]` pairs, in order from least\n    recently used to most recently used.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `getRemainingTTL(key)`\n\n    Return the number of ms left in the item's TTL.  If item is not in\n    cache, returns `0`.  Returns `Infinity` if item is in cache without a\n    defined TTL.\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Storage Bounds Safety\n\nThis implementation aims to be as flexible as possible, within the limits\nof safe memory consumption and optimal performance.\n\nAt initial object creation, storage is allocated for `max` items.  If `max`\nis set to zero, then some performance is lost, and item count is unbounded.\nEither `maxSize` or `ttl` _must_ be set if `max` is not specified.\n\nIf `maxSize` is set, then this creates a safe limit on the maximum storage\nconsumed, but without the performance benefits of pre-allocation.  When\n`maxSize` is set, every item _must_ provide a size, either via the\n`sizeCalculation` method provided to the constructor, or via a `size` or\n`sizeCalculation` option provided to `cache.set()`.  The size of every item\n_must_ be a positive integer.\n\nIf neither `max` nor `maxSize` are set, then `ttl` tracking must be\nenabled.  Note that, even when tracking item `ttl`, items are _not_\npreemptively deleted when they become stale, unless `ttlAutopurge` is\nenabled.  Instead, they are only purged the next time the key is requested.\nThus, if `ttlAutopurge`, `max`, and `maxSize` are all not set, then the\ncache will potentially grow unbounded.\n\nIn this case, a warning is printed to standard error.  Future versions may\nrequire the use of `ttlAutopurge` if `max` and `maxSize` are not specified.\n\nIf you truly wish to use a cache that is bound _only_ by TTL expiration,\nconsider using a `Map` object, and calling `setTimeout` to delete entries\nwhen they expire.  It will perform much better than an LRU cache.\n\nHere is an implementation you may use, under the same [license](./LICENSE)\nas this package:\n\n```js\n// a storage-unbounded ttl cache that is not an lru-cache\nconst cache = {\n  data: new Map(),\n  timers: new Map(),\n  set: (k, v, ttl) => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.set(k, setTimeout(() => cache.del(k), ttl))\n    cache.data.set(k, v)\n  },\n  get: k => cache.data.get(k),\n  has: k => cache.data.has(k),\n  delete: k => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.delete(k)\n    return cache.data.delete(k)\n  },\n  clear: () => {\n    cache.data.clear()\n    for (const v of cache.timers.values()) {\n      clearTimeout(v)\n    }\n    cache.timers.clear()\n  }\n}\n```\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"711c7be43a93a5c67574343fcef977019454d2b0","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.7.4","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-mQK1gl/pguIRj8m1VizoMknnzDn8bjxxFPJNtXTQdQWIlGzNIQWEqvSuEoe/fYfgusWQYFXR/muGmGnaYzLfPA==","shasum":"7fabe5409884d3d2bd88292e431e49494d84ca13","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.7.4.tgz","fileCount":4,"unpackedSize":49717,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDecKDxuAr1gpXF2O/WbhJrYgCZyHLp/19/6zBlGzreVQIhAKkFf0W+IHC2qXcCMQLBKvSXSzCYKLaqeg44xJDDufOV"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUd1WACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqr2g//R4qvmXMwJ4HqmcMrzIFuyLPBvylOWV4xsZsXc3TlPzF9YhtV\r\nmnOqG84cygYlGczs1IV9kWSGcaUBu4Y1rGYuuJDpmENLHZRLOk1pSayP6GWb\r\n2+Pg17jLEUvdpQ4S8dz+rgwwn+nFCDKsbucoMYYG/LrhXlvcmp7BjLXTMaNB\r\nxR+3gzMO84cV1QHoGCuWSOsdWHlPN8N/joG0NWNScqSKLiJbuiZZUdAcAUfm\r\nnyfEQPUWe7W7HGU7rN/oZr1/+bJ79T9LopYhyPBuhTbd+oyreLrNlX4XLClK\r\n3+ruwuOD1zyIYKySpIRt9gspYNH8a3j1eZkR3X6DN4qnnuhB8G3RV6uzOS0F\r\nk2vygBTMFSwOiHM+F3P8lBV6WZ5n0xHCIaBMM9F8zXyPLvSniTS/HbTHbdj6\r\nkXwN7Mp+hUQUVXAg7sCun1vlgnLzWH8G65puyUMUklHmzwBFYiPEvhGxup5N\r\n94mE5AAne/QigHaaaryKpgh1j3qMMJn/UVAYvfA4jQTblIcXqpMkovjvrA5l\r\nyOHnezE4123EtB4YitA1jNH06KMeyx28aXG7YiAqSLCuvVGmWr2zWKrP5yl4\r\nibM4PkhONO85h326lJcvECFboD8HlSi4x82VYfVpreneQ9UH/xmkuSlLFqmV\r\nQDupqQTR5khHHRVQ8l917RuLanqWvNXDYC8=\r\n=FoIV\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.7.4_1649532246628_0.032840497097149646"},"_hasShrinkwrap":false},"7.6.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.6.1","publishConfig":{"tag":"v7.6-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","heapdump":"^0.3.15","size-limit":"^7.0.8","tap":"^16.0.1"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n\n  max: 500, // <-- Technically optional, but see \"Storage Bounds Safety\" below\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n    At least one of `max`, `maxSize`, or `TTL` is required.  This must be a\n    positive integer if set.\n\n    **It is strongly recommended to set a `max` to prevent unbounded growth\n    of the cache.**  See \"Storage Bounds Safety\" below.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n    Optional, must be a positive integer if provided.  Required if other\n    size tracking features are used.\n\n    At least one of `max`, `maxSize`, or `TTL` is required.  This must be a\n    positive integer if set.\n\n    Even if size tracking is enabled, **it is strongly recommended to set a\n    `max` to prevent unbounded growth of the cache.**  See \"Storage Bounds\n    Safety\" below.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argument.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `fetchMethod` Function that is used to make background asynchronous\n  fetches.  Called with `fetchMethod(key, staleValue)`.  May return a\n  Promise.\n\n    If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n    to `Promise.resolve(cache.get(key))`.\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `disposeAfter` The same as `dispose`, but called _after_ the entry is\n  completely removed and the cache is once again in a clean state.\n\n    It is safe to add an item right back into the cache at this point.\n    However, note that it is _very_ easy to inadvertently create infinite\n    recursion in this way.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` or `disposeAfter`\n    options are set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    At least one of `max`, `maxSize`, or `TTL` is required.  This must be a\n    positive integer if set.\n\n    Even if ttl tracking is enabled, **it is strongly recommended to set a\n    `max` to prevent unbounded growth of the cache.**  See \"Storage Bounds\n    Safety\" below.\n\n    If ttl tracking is enabled, and `max` and `maxSize` are not set, and\n    `ttlAutopurge` is not set, then a warning will be emitted cautioning\n    about the potential for unbounded memory consumption.\n\n    Deprecated alias: `maxAge`\n\n* `noUpdateTTL` - Boolean flag to tell the cache to not update the TTL when\n  setting a new value for an existing key (ie, when updating a value rather\n  than inserting a new value).  Note that the TTL value is _always_ set\n  (if provided) when adding a new entry into the cache.\n\n    This may be passed as an option to `cache.set()`.\n\n    Boolean, default false.\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n    Returns the cache object.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `async fetch(key, { updateAgeOnGet, allowStale } = {}) => Promise`\n\n    If the value is in the cache and not stale, then the returned Promise\n    resolves to the value.\n\n    If not in the cache, or beyond its TTL staleness, then\n    `fetchMethod(key, staleValue)` is called, and the value returned will\n    be added to the cache once resolved.\n\n    If called with `allowStale`, and an asynchronous fetch is currently in\n    progress to reload a stale value, then the former stale value will be\n    returned.\n\n    Multiple fetches for the same `key` will only call `fetchMethod` a\n    single time, and all will be resolved when the value is resolved.\n\n    If `fetchMethod` is not specified, then this is an alias for\n    `Promise.resolve(cache.get(key))`.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n    Returns `true` if the key was deleted, `false` otherwise.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache, in order from most\n    recently used to least recently used.\n\n* `rkeys()`\n\n    Return a generator yielding the keys in the cache, in order from least\n    recently used to most recently used.\n\n* `values()`\n\n    Return a generator yielding the values in the cache, in order from most\n    recently used to least recently used.\n\n* `rvalues()`\n\n    Return a generator yielding the values in the cache, in order from\n    least recently used to most recently used.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs, in order from most\n    recently used to least recently used.\n\n* `rentries()`\n\n    Return a generator yielding `[key, value]` pairs, in order from least\n    recently used to most recently used.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `getRemainingTTL(key)`\n\n    Return the number of ms left in the item's TTL.  If item is not in\n    cache, returns `0`.  Returns `Infinity` if item is in cache without a\n    defined TTL.\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Storage Bounds Safety\n\nThis implementation aims to be as flexible as possible, within the limits\nof safe memory consumption and optimal performance.\n\nAt initial object creation, storage is allocated for `max` items.  If `max`\nis set to zero, then some performance is lost, and item count is unbounded.\nEither `maxSize` or `ttl` _must_ be set if `max` is not specified.\n\nIf `maxSize` is set, then this creates a safe limit on the maximum storage\nconsumed, but without the performance benefits of pre-allocation.  When\n`maxSize` is set, every item _must_ provide a size, either via the\n`sizeCalculation` method provided to the constructor, or via a `size` or\n`sizeCalculation` option provided to `cache.set()`.  The size of every item\n_must_ be a positive integer.\n\nIf neither `max` nor `maxSize` are set, then `ttl` tracking must be\nenabled.  Note that, even when tracking item `ttl`, items are _not_\npreemptively deleted when they become stale, unless `ttlAutopurge` is\nenabled.  Instead, they are only purged the next time the key is requested.\nThus, if `ttlAutopurge`, `max`, and `maxSize` are all not set, then the\ncache will potentially grow unbounded.\n\nIn this case, a warning is printed to standard error.  Future versions may\nrequire the use of `ttlAutopurge` if `max` and `maxSize` are not specified.\n\nIf you truly wish to use a cache that is bound _only_ by TTL expiration,\nconsider using a `Map` object, and calling `setTimeout` to delete entries\nwhen they expire.  It will perform much better than an LRU cache.\n\nHere is an implementation you may use, under the same [license](./LICENSE)\nas this package:\n\n```js\n// a storage-unbounded ttl cache that is not an lru-cache\nconst cache = {\n  data: new Map(),\n  timers: new Map(),\n  set: (k, v, ttl) => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.set(k, setTimeout(() => cache.del(k), ttl))\n    cache.data.set(k, v)\n  },\n  get: k => cache.data.get(k),\n  has: k => cache.data.has(k),\n  delete: k => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.delete(k)\n    return cache.data.delete(k)\n  },\n  clear: () => {\n    cache.data.clear()\n    for (const v of cache.timers.values()) {\n      clearTimeout(v)\n    }\n    cache.timers.clear()\n  }\n}\n```\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"8822133dbdee2deb1d92b96e9bea14c447a4ba8f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.6.1","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-ggu423hHChjuFdz9BYpHGSgiYBFV8zJD23WSB1QoLGqX4PGRYc4zg+MblXgPWHToYcUi4TpOxujb1baqgJMynQ==","shasum":"14a52901b083ea4f8ea6b7ea9eedf8f31d0d32e3","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.6.1.tgz","fileCount":4,"unpackedSize":46709,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEWr0Y1GMgKCNIQRzDeF5s0a7S+HR7khGfaxRYxNOKmJAiAMk+Ie5srzNwV6jLYi0UC5XuYVuVlwkAyiVq3AtEUeZQ=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUd4SACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqhIxAAkcs4BzVkxefp1+B31RQe1scW40a8wyOupjSEwuG0B2Yw+PL0\r\ndE3ab4QjU359QxyHftT2y9zBWf0lPVDkP0D/VIcSHM00KyNecxBz6wCUk3Ju\r\nADelZfIymVpgyTbXndzt/T7AmK2aI8Z3OlG3K4Az36JPdJLUMFHAl5H9eIl1\r\ni59uePFM/i1cETbcr0vPc301WdwiPyWed+LDav3z6+R8Rfp4RGcdJuggdMzj\r\nvrwVRhcdz3zsVotZrE8MR1gxFnzP8+lUmn734vjJA6LrAnGIuOwe1diEGvn4\r\niiek68raRPZhvsri1Lpd5LDqP17fBtNk/8cs4YOCYUjZ5fYjW/fV6WtyEzzH\r\nEHxgPn60QAFalw/4R2gqpZI3V1CGHcYBL/O8pHe9HoptWTad2zVShpog3I9f\r\nrXpl6/bfmrKLRuvMGEtmxpUYUAMLo5qEC9CynB2M8FC6HRVsnfB9f5eyNUia\r\ncQ5UJ7sNjkSm0M1oORM6Yw7warT6BBEwwyCXGVyS4bImVD0yo7S+Xbbm58Fl\r\n1bu0gqiQ1npo8KIGIDjp+xj65B2wQGeqm7xdTMelcWoY/oym2WGmXzhVNezk\r\nj7UHbyokXMZi0oxn1Tq8cYhHNAz2GZBlil5R3QwqVsq1RmTjLwvwm+lgKuBN\r\nJAkd8Hzc17RxGuVmlqCmKxhWzx/c6SAudiw=\r\n=O5Wb\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.6.1_1649532433838_0.13480944572485698"},"_hasShrinkwrap":false},"7.5.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.5.2","publishConfig":{"tag":"v7.5-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","heapdump":"^0.3.15","size-limit":"^7.0.8","tap":"^16.0.1"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n\n  max: 500, // <-- mandatory, you must give a maximum capacity\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n    This option is required, and must be a positive integer.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n    Optional, must be a positive integer if provided.  Required if other\n    size tracking features are used.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argument.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `disposeAfter` The same as `dispose`, but called _after_ the entry is\n  completely removed and the cache is once again in a clean state.\n\n    It is safe to add an item right back into the cache at this point.\n    However, note that it is _very_ easy to inadvertently create infinite\n    recursion in this way.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` or `disposeAfter`\n    options are set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `noUpdateTTL` - Boolean flag to tell the cache to not update the TTL when\n  setting a new value for an existing key (ie, when updating a value rather\n  than inserting a new value).  Note that the TTL value is _always_ set\n  (if provided) when adding a new entry into the cache.\n\n    This may be passed as an option to `cache.set()`.\n\n    Boolean, default false.\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n    Returns the cache object.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n    Returns `true` if the key was deleted, `false` otherwise.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache, in order from most\n    recently used to least recently used.\n\n* `rkeys()`\n\n    Return a generator yielding the keys in the cache, in order from least\n    recently used to most recently used.\n\n* `values()`\n\n    Return a generator yielding the values in the cache, in order from most\n    recently used to least recently used.\n\n* `rvalues()`\n\n    Return a generator yielding the values in the cache, in order from\n    least recently used to most recently used.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs, in order from most\n    recently used to least recently used.\n\n* `rentries()`\n\n    Return a generator yielding `[key, value]` pairs, in order from least\n    recently used to most recently used.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"5c146c6720c3b73cd69b3e3ffe700d70a6818f1f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.5.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-Vd4QEKEWXQeV20F2GffIwDYYDcplgpcozPDzv59jD8+AUgmVYCATaFrZu4efkCeYfMeJsOz6ZnkdWPssI4jRyQ==","shasum":"f7da8d0a1906bacb397e0747796d53b08441d877","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.5.2.tgz","fileCount":4,"unpackedSize":38582,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBnlbNyVMFE95e99TnWRu+SVjFDKNkpArNaMkm9Q1OZvAiA4o/z1061FIY0O4NzI3VJQyQUeXHW84xLi1LSeuxxf+g=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUd+tACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqFQhAAlI23dVUimew3/NixwYBAgkfIEqFnqu2CIuvC/+nGMziTzfhy\r\n7pvOoZAB+yibZ01O8kHpe4LSBXUJizY2Kkfb/da8xtni0jGzrIZ3X9O1PPFm\r\n7rpt/lIO3XY8s1bWyvhmQvW5K3qZjkGBCXxfO4PXm/X2+ELrj1ZpNGktpWw5\r\nm2Q9yaDfgvv1tYBEUXRbe/cEj43buF3dUcYZAQsg8CIh6lvq1d1wQuE91TEP\r\nbseJU2zeggUgh70cdfy+IdWL91dUTruCAd5PUgrzOIT2YrOWdg4JWSGwqvZ2\r\nW6VBzZQiK5xsFRAkG7Br5amr3ETXqcmrnowpOaw0yFOg4GK0cCmk+W1cjgkR\r\nJqSULeoS3bw15ELDyRIwvj9KQ2/dLaAr1LWLR98RMTFjCN8sGHHmNyX4Kz/x\r\nCoFS4rj0lb7GhumRaze+8aQEgbVBydQQ23EMaMV+OkSXBnZ4VQp8PZNsHCJS\r\nx07x1bOn4kWzq2R1Cmym5CUYT5yryH6XVTWF3yy0llNej4CAdfV/s45199bf\r\nDjmSX0qbs8TlqZoqurYyFt6V3caoTn2MrO3Vn5T6CXnNyaNBXKR6fUftDqh+\r\nbCnUGInoR7L/Q0MK6sjf09Xx5BgNnkGi9znO4DUf+UovNCnXIq0etoO6/0d2\r\nv260kUfKmKYnfb8vcNnuuTBWz+DTg6cecLI=\r\n=IPKL\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.5.2_1649532845651_0.6747761236685403"},"_hasShrinkwrap":false},"7.4.5":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.4.5","publishConfig":{"tag":"v7.4-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"prepare":"webpack-cli -o bundle ./index.js --node-env production","build":"npm run prepare","presize":"npm run prepare","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","browser":"./bundle/main.js","exports":{".":"./index.js","./browser":"./bundle/main.js"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","heapdump":"^0.3.15","size-limit":"^7.0.8","tap":"^16.0.1","webpack-cli":"^4.9.2"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./bundle/main.js"}],"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n\n  max: 500, // <-- mandatory, you must give a maximum capacity\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n    This option is required, and must be a positive integer.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n    Optional, must be a positive integer if provided.  Required if other\n    size tracking features are used.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argument.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `disposeAfter` The same as `dispose`, but called _after_ the entry is\n  completely removed and the cache is once again in a clean state.\n\n    It is safe to add an item right back into the cache at this point.\n    However, note that it is _very_ easy to inadvertently create infinite\n    recursion in this way.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` or `disposeAfter`\n    options are set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `noUpdateTTL` - Boolean flag to tell the cache to not update the TTL when\n  setting a new value for an existing key (ie, when updating a value rather\n  than inserting a new value).  Note that the TTL value is _always_ set\n  (if provided) when adding a new entry into the cache.\n\n    This may be passed as an option to `cache.set()`.\n\n    Boolean, default false.\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n    Returns the cache object.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n    Returns `true` if the key was deleted, `false` otherwise.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"a801dc9da5b3efdc00369db735e3666978fb6a1f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.4.5","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-tT5jwefAV3F9AxyRPO/HrupMB4iLwae2a3sPMzttYKQBxc2/qaOdKUJxGZ3q2pihiHasDfpNkuNHGk92cb4RyA==","shasum":"818618db4de37bca83292f46362429124d6f0d45","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.4.5.tgz","fileCount":5,"unpackedSize":46234,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIH+gIG94US0mL/Ypi5busNzn2N+GHn42RDTFWyQfjWRTAiAWX2CEPWGzVler8uZKHCgzuBzoyaVUESCDe1iagRY8zQ=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUeAbACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqSDQ//YioQDw2U0G5lUiyxYBj/tjY7pn2vs/eZX0DLboDHzLml6tmg\r\nH1oMxY7n6ECNKwvQikYRkI4692ZO+MSL0T3VvU7338xVBdU+n+A89De7Th4k\r\nUOwDS9j0ewGVKS0u9SotA7vC5FRdomnyTNRmCnMDZYAlncu23Vn4BMComf6g\r\n0G/kT3X+Kx4iAC5CQ2AJN9YITwU2Ox2bSW4GCFGuFqM6iSW+0sW4GpM8Vllw\r\nh6clsowh2TQTuz4YnzjpLALnAqBYgSlOuquc/sgZretpdsSHH8xkQMo3iTmm\r\nWMr5Q3etFQagNPmKGmhZcKozsQPtQEzfhQIBTJ44UG6GY5CzGiZbGUHqrrM8\r\nl1huYFv7KO8i7HB/vVFDDSxsW4RpZM4B2KPxDH0+zy4eLlrHrkmPpNL5WLFh\r\n+bAVKHCaW8P7MjxlygebpT9ZCDFfz1peJHU/IwBBw7RYF6ffdsSnf4HxA5I5\r\nvn6LLvyP+7FLAwq7VQlZucQZSJET7QzH0ojdhu+kSloSG4SHthAamFHGtn0x\r\nVKJ+phhy7FC5LmOuPlVqSM1lkezNiW0JvCgIfEbkejeEHR6bsXnn+De2QZmv\r\n2UOTlkej3giOLVg+IzGU/nt8krD+2ECArNEmN4Gw57SnmndPU80AXKgxkPj4\r\nwEJL6nRmKrzQslqE2mRdZdWu3gZBqFwXHWY=\r\n=aVo7\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.4.5_1649532955073_0.007987751944029231"},"_hasShrinkwrap":false},"7.3.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.3.3","publishConfig":{"tag":"v7.3-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","heapdump":"^0.3.15","tap":"^16.0.1"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argument.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `disposeAfter` The same as `dispose`, but called _after_ the entry is\n  completely removed and the cache is once again in a clean state.\n\n    It is safe to add an item right back into the cache at this point.\n    However, note that it is _very_ easy to inadvertently create infinite\n    recursion in this way.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n    Returns the cache object.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n    Returns `true` if the key was deleted, `false` otherwise.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"9ea6b31e6ea8ee76df808a26b64f133409ffc36b","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.3.3","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-wQNrRksJ6nnJTNGKgCiOhfIm8l+H6/Ar227nSwRlSAMBKFQdhdnd03DXRZyLLbaNruqPP5h3QsVboG30/MG9mA==","shasum":"a78f086b73a6eb4b61cda8e3e1b86387b4b81d33","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.3.3.tgz","fileCount":4,"unpackedSize":36651,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGWypo+Zh8uCvPegvA9/WtcXEzK//ulOFwNpmAgcGMb3AiEAnLHnACHZh+r4zudUUubD2I9bpR0WC6TDi4iJ6ojaGqo="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUeCSACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmotuQ/8CFogSKtqlacr2AS6dlJSTjqWRG5MWk2Xs8YkxIn2LqKdamDP\r\naXFlxghjADewICdefoW6W025aqdqQzN2UTTnF9mmbGJAcN+6pl+19yR71epN\r\nEAD2ZJDUvdt7zk+3aQH7vhH+T49zmMLkD+gbODiJhZAV+CVTjkf5PAYXhqFc\r\nje/X6ZufaaLRPDkrNchFgOph8ALMa9OJdDffC5jOl1sIH/oPRsPpIdcSx6Lu\r\nGvYUs1BjPdW6Shjl3d4YaIfv/McVa37uGz1PwyyVhIbNaITARHGSbwQBtsEi\r\nEe5ujIstUdrzAb77QAfcEy0P13NleNVm/BP9wZ5YFL0FgwWzDjkwIluD8wMn\r\nV3xNRMhuZ+bjUql2Q+fDBL6U4Vs1eaikAJvUbBWmtH+TXSAb9HG+7vBnPn+o\r\nheNiUBwbqmNTuzF0opz+vel0QaxXBOe/36j19Cg5uRs9AGmTQt3gvtVO+8AL\r\nIhm2bD4I6vYlIyrjPcFju8X/j80SLfoCZ8P761z4qI8cmzL1APkzlFqjpHM7\r\nXykvg6elckgvQfS+eEKIZndymBpYkGh93srs25mnHOKWCbRpv3AqUTynmfxm\r\ne0//rZJzSNChDo4q6VtOqjUA9y7VqLdm7tO6duAyqnAwIDQH08HkHwAaLW/p\r\n9DHgU7Bjkn37EkYF1b08FHB2LoJg0HsZ3R8=\r\n=e10Y\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.3.3_1649533074055_0.05583952193172492"},"_hasShrinkwrap":false},"7.2.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.2.3","publishConfig":{"tag":"v7.2-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","heapdump":"^0.3.15","tap":"^16.0.1"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache, as `this.dispose(value, key, reason)`.\n\n    This can be handy if you want to close file descriptors or do other\n    cleanup tasks when items are no longer stored in the cache.\n\n    **NOTE**: It is called *before* the item has been fully removed from\n    the cache, so if you want to put it right back in, you need to wait\n    until the next tick.  If you try to add it back in during the\n    `dispose()` function call, it will break things in subtle and weird\n    ways.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    The `reason` will be one of the following strings, corresponding to the\n    reason for the item's deletion:\n\n    * `evict` Item was evicted to make space for a new addition\n    * `set` Item was overwritten by a new value\n    * `delete` Item was removed by explicit `cache.delete(key)` or by\n      calling `cache.clear()`, which deletes everything.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"83732579b980df95d5215886e701fcb1cc3087df","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.2.3","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-aS92ErFQmSZtXltSlLANepZOpcveIDHIpStGPzwWHJYFS956qGp2BpN5Mc5r1ZFyJCLQ9CsVIQTGRZpUrRo3NA==","shasum":"fbd88fb36e3c2abe413c5258eae7f4587c44fabf","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.2.3.tgz","fileCount":4,"unpackedSize":34999,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCbf69H2BE/NDJS6HfOA9/nraZrCcUpNDYdEKwtHEwt5wIhAMuzuFMg63RQZjMrVJGHxVy1F3oWCbRp7sk37zr6mSuP"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUeEBACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoZCg//QOEbRZNhAQI2noxwDtYuUzgT9ifDpNJfZ4royGvD9vcOi46o\r\nLTziG9hoFO22S5KBlmOKqJ1pTRrsMMHeyCZd5WlavjRJI7PHk6WKu8ptZl4R\r\n05iCf33XzVdOYyjsP0mSvr++vF9cthqJL0V0ZCJ42YFbs05q6r+fGp/6wRsC\r\nYqNSUrsqU+7UmH46bLTyuoLUebRvP5XzJrjZAnzLeSCKVs3uM+KliPwKgLg5\r\nuOlTmhzOFjolgpKUCPMP+ere28JLa6Z69jUlcBOqtYVcYVOqL0lK0IME0Hm0\r\nfLwbmfWVySVUA0DJM28W13T9cvPyMjDeE+jOKuh3sf77cRYKHS87FcaqcUeR\r\nx53Q9EpTmwpxIPhGJtDNQjhYIO3JfTCgU1xNrShiXxvSsISd2bZKm9cfd/yw\r\npSg0r1DciRk1yjVUGAQcu7QZRD8380Blrl+uOYtppf2bV+OwV+ky3mqZw65x\r\nI+ZD9dQFy2NiURILM9tl+sbvF4CPjLFq/nCWCuQLAEtMOMQ7ujzcQ6OPZ38j\r\nT/RFaW7tLHJeTNZd13Dmgr+lHCrZGEoWspdaP8rRJD3zRO5uGlTSU9cFPEUu\r\njfBdRmxV8CpsuYjCRgdjTFYFfJxQ5jQMppHH6Vafbg3xQC8fTSd5T+EyAGnX\r\nWqqRGh2OIi247GqJQhiZeNK2zFjl1Zlz8UU=\r\n=pjFI\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.2.3_1649533185138_0.0879470212388509"},"_hasShrinkwrap":false},"7.1.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.1.3","publishConfig":{"tag":"v7.1-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","heapdump":"^0.3.15","tap":"^16.0.1"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed by default,\n  // and MAY live in the cache, contributing to its LRU max, long after\n  // they have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  stored in the cache.\n\n    It is called *after* the item has been fully removed from the cache, so\n    if you want to put it right back in, that is safe to do.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed by default, and MAY\n  live in the cache, contributing to its LRU max, long after they have\n  expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `ttlResolution` - Minimum amount of time in ms in which to check for\n  staleness.  Defaults to `1`, which means that the current time is checked\n  at most once per millisecond.\n\n    Set to `0` to check the current time every time staleness is tested.\n\n    Note that setting this to a higher value _will_ improve performance\n    somewhat while using ttl tracking, albeit at the expense of keeping\n    stale items around a bit longer than intended.\n\n* `ttlAutopurge` - Preemptively remove stale items from the cache.\n\n    Note that this may _significantly_ degrade performance, especially if\n    the cache is storing a large number of items.  It is almost always best\n    to just leave the stale items in the cache, and let them fall out as\n    new items are added.\n\n    Note that this means that `allowStale` is a bit pointless, as stale\n    items will be deleted almost as soon as they expire.\n\n    Use with caution!\n\n    Boolean, default `false`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  preemptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.maxSize`, `cache.allowStale`, `cache.noDisposeOnSet`,\n  `cache.sizeCalculation`, `cache.dispose`, `cache.maxSize`, `cache.ttl`,\n  `cache.updateAgeOnGet`\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n    Deprecated alias: `prune`\n\n* `forEach(fn, [thisp])`\n\n    Call the `fn` function with each set of `fn(value, key, cache)` in the\n    LRU cache, from most recent to least recently used.\n\n    Does not affect recency of use.\n\n    If `thisp` is provided, function will be called in the `this`-context\n    of the provided object.\n\n* `rforEach(fn, [thisp])`\n\n    Same as `cache.forEach(fn, thisp)`, but in order from least recently\n    used to most recently used.\n\n* `pop()`\n\n    Evict the least recently used item, returning its value.\n\n    Returns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\" members and\nmethods are exposed on the object as normal properties, rather than being\naccessed via Symbols, private members, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.  There\nis no need or reason to ever call them directly.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**  They will be\nignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by internal ID\n* `isStale(index)` Called to check an item's staleness, by internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item size.\n  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation when an\n  item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when an item\n  is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from most\n  recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from least\n  recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted ID,\n  evicting the least recently used ID, or walking to the end of the\n  allotted space.\n* `evict()` Evict the least recently used internal ID, returning its ID.\n  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the linked list.\n* `moveToTail(index)` Move the specified internal ID to the most recently\n  used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do\n   that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache) which\n   uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys, and use [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that look like\n   floats, `null`, objects, or some mix of types, or if you aren't sure,\n   then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially ttl\n   behavior, unless absolutely needed.  These features are convenient, and\n   necessary in some use cases, and every attempt has been made to make the\n   performance impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","gitHead":"90980da4996ec7b91048bd13b0a801047892e5ab","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.1.3","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-cJyvx0rDiKcK4VXaLUoR1aaSbWJ+ONdYcyIjw0cOjaj4Z6oAcxYejWpkYRu6DqTRbYvBBijnLMiffdUJDYLF1A==","shasum":"8aab7e6d92732a0218b9df5b7218dd32ef2b414d","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.1.3.tgz","fileCount":4,"unpackedSize":34204,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQChAD+0BQTCXwqtcsRu5kKpLtGs5AQtrfFGe2m3lvKTswIhAL9I/2SrXGPNErV9gWJnuoM/j2gnXp+/JAX5KcTjWBXo"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUeFyACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqULRAAmY8adZuDNmPsWMLsWAwvxPxWODRkaf8HjrK347yC+gUYAikQ\r\nz9RUY0crHae4EC2G4s8OMDCqtw2uj3t7XPGhNJkrS3SwnzT3JDBD9J/LBsQa\r\niMMdGjZ7LD38dJaA/o6KkOrZGyVhl+5A3ho3X3CxjULt87CGmyMkDYqE9Hmq\r\nKvWNQIlhyDkJDT7hh7ZF3cFcs5pA0ttLevLwOmBOQVtxYahjz0E2fhdyOHfl\r\nU4HNBRbgYqY7Z1wJXslqLRsqau5CiGuc4P+qY0zW7UH8c623P3/HBdHwNweQ\r\nG5s72cAPbHKqlPmpCJ1pAHcsB2AYU2G2pvBgfqWSGsn1Hk8qzLjeHfpl4+Ul\r\n1Km4uqhNw0d+Sj7PFPHTHxUk+olyF0olF7dtKJWCuhx7Ie8l8N5VlvlNZkH7\r\nHzyfjrS388WGA+yWR+SazMXhbzgE6/YKrRHv/0jIio6ABPu9R+91lza7dXu+\r\nkQM/ueTj7dAPk25Og/ZLV2bzZpQpRgZOMbQmNMBmQmYn8OmkV19gBc9oQpuk\r\n1RXuJbSTL0JVwLR5+lX9AWrQs2hj8XuujrY3pZCtlbUSarBGLKSvwL47DB5r\r\n6g/DLHoHEu/tOVLtZjj3MtYjRP1bkseK7Lvqr5hl2TTGLnUeSBqN+rVPEnAV\r\nJabbMssvoZNKIP/FsHwNA+ishlj0ooeRC40=\r\n=3iPk\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.1.3_1649533298102_0.8880244259816878"},"_hasShrinkwrap":false},"7.0.4":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.0.4","publishConfig":{"tag":"v7.0-backport"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"benchmark":"^2.1.4","heapdump":"^0.3.15","tap":"^16.0.1"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you want to keep,\nand this cache will keep that many of the most recently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL guarantees.\nThere is no preemptive pruning of expired items, but you _may_ set a TTL\non the cache or on a single `set`.  If you do so, it will treat expired\nitems as missing, and delete them when fetched.\n\nAs of version 7, this is one of the most performant LRU implementations\navailable in JavaScript, and supports a wide diversity of use cases.\nHowever, note that using some of the features will necessarily impact\nperformance, by causing the cache to have to do more work.  See the\n\"Performance\" section below.\n\n## Installation\n\n```js\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// only 'max' is required, the others are optional, but MAY be\n// required if certain other fields are set.\nconst options = {\n  // the number of most recently used items to keep.\n  // note that we may store fewer items than this if maxSize is hit.\n  max: 500,\n\n  // if you wish to track item size, you must provide a maxSize\n  // note that we still will only keep up to max *actual items*,\n  // so size tracking may cause fewer than max items to be stored.\n  // At the extreme, a single item of maxSize size will cause everything\n  // else in the cache to be dropped when it is added.  Use with caution!\n  // Note also that size tracking can negatively impact performance,\n  // though for most cases, only minimally.\n  maxSize: 5000,\n\n  // function to calculate size of items.  useful if storing strings or\n  // buffers or other items where memory size depends on the object itself.\n  // also note that oversized items do NOT immediately get dropped from\n  // the cache, though they will cause faster turnover in the storage.\n  sizeCalculation: (value, key) => {\n    // return an positive integer which is the size of the item,\n    // if a positive integer is not returned, will use 0 as the size.\n    return 1\n  },\n\n  // function to call when the item is removed from the cache\n  // Note that using this can negatively impact performance.\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // max time to live for items before they are considered stale\n  // note that stale items are NOT preemptively removed, and MAY\n  // live in the cache, contributing to its LRU max, long after they\n  // have expired.\n  // Also, as this cache is optimized for LRU/MRU operations, some of\n  // the staleness/TTL checks will reduce performance, as they will incur\n  // overhead by deleting items.\n  // Must be a positive integer in ms, defaults to 0, which means \"no TTL\"\n  ttl: 1000 * 60 * 5,\n\n  // return stale items from cache.get() before disposing of them\n  // boolean, default false\n  allowStale: false,\n\n  // update the age of items on cache.get(), renewing their TTL\n  // boolean, default false\n  updateAgeOnGet: false,\n\n  // update the age of items on cache.has(), renewing their TTL\n  // boolean, default false\n  updateAgeOnHas: false,\n\n  // update the \"recently-used\"-ness of items on cache.has()\n  // boolean, default false\n  updateRecencyOnHas: false,\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n* `max` - The maximum number (or size) of items that remain in the cache\n  (assuming no TTL pruning or explicit deletions).  Note that fewer items\n  may be stored if size calculation is used, and `maxSize` is exceeded.\n  This must be a positive finite intger.\n\n* `maxSize` - Set to a positive integer to track the sizes of items added\n  to the cache, and automatically evict items in order to stay below this\n  size.  Note that this may result in fewer than `max` items being stored.\n\n* `sizeCalculation` - Function used to calculate the size of stored\n  items.  If you're storing strings or buffers, then you probably want to\n  do something like `n => n.length`.  The item is passed as the first\n  argument, and the key is passed as the second argumnet.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Requires `maxSize` to be set.\n\n    Deprecated alias: `length`\n\n* `dispose` Function that is called on items when they are dropped\n  from the cache.  This can be handy if you want to close file\n  descriptors or do other cleanup tasks when items are no longer\n  stored in the cache.\n\n    It is called *after* the item has been fully removed from the cache, so\n    if you want to put it right back in, that is safe to do.\n\n    Unlike several other options, this may _not_ be overridden by passing\n    an option to `set()`, for performance reasons.  If disposal functions\n    may vary between cache entries, then the entire list must be scanned\n    on every cache swap, even if no disposal function is in use.\n\n    Optional, must be a function.\n\n* `noDisposeOnSet` Set to `true` to suppress calling the `dispose()`\n  function if the entry key is still accessible within the cache.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Boolean, default `false`.  Only relevant if `dispose` option is set.\n\n* `ttl` - max time to live for items before they are considered stale.\n  Note that stale items are NOT preemptively removed, and MAY live in the\n  cache, contributing to its LRU max, long after they have expired.\n\n    Also, as this cache is optimized for LRU/MRU operations, some of\n    the staleness/TTL checks will reduce performance, as they will incur\n    overhead by deleting from Map objects rather than simply throwing old\n    Map objects away.\n\n    This is not primarily a TTL cache, and does not make strong TTL\n    guarantees.  There is no pre-emptive pruning of expired items, but you\n    _may_ set a TTL on the cache, and it will treat expired items as missing\n    when they are fetched, and delete them.\n\n    Optional, but must be a positive integer in ms if specified.\n\n    This may be overridden by passing an options object to `cache.set()`.\n\n    Deprecated alias: `maxAge`\n\n* `allowStale` - By default, if you set `ttl`, it'll only delete stale\n  items from the cache when you `get(key)`.  That is, it's not\n  pre-emptively pruning items.\n\n    If you set `allowStale:true`, it'll return the stale value as well as\n    deleting it.  If you don't set this, then it'll return `undefined` when\n    you try to get a stale entry.\n\n    Note that when a stale entry is fetched, _even if it is returned due to\n    `allowStale` being set_, it is removed from the cache immediately.  You\n    can immediately put it back in the cache if you wish, thus resetting the\n    TTL.\n\n    This may be overridden by passing an options object to `cache.get()`.\n    The `cache.has()` method will always return `false` for stale items.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n    Deprecated alias: `stale`\n\n* `updateAgeOnGet` - When using time-expiring entries with `ttl`, setting\n  this to `true` will make each item's age reset to 0 whenever it is\n  retrieved from cache with `get()`, causing it to not expire.  (It can\n  still fall out of cache based on recency of use, of course.)\n\n    This may be overridden by passing an options object to `cache.get()`.\n\n    Boolean, default false, only relevant if `ttl` is set.\n\n## API\n\n* `new LRUCache(options)`\n\n    Create a new LRUCache.  All options are documented above, and are on\n    the cache as public members.\n\n* `cache.max`, `cache.ttl`, `cache.allowStale`, etc.\n\n    All option names are exposed as public members on the cache object.\n\n    These are intended for read access only.  Changing them during program\n    operation can cause undefined behavior.\n\n* `cache.size`\n\n    The total number of items held in the cache at the current moment.\n\n* `cache.calculatedSize`\n\n    The total size of items in cache when using size tracking.\n\n* `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet }])`\n\n    Add a value to the cache.\n\n    Optional options object may contain `ttl` and `sizeCalculation` as\n    described above, which default to the settings on the cache object.\n\n    Options object my also include `size`, which will prevent calling the\n    `sizeCalculation` function and just use the specified number if it is a\n    positive integer, and `noDisposeOnSet` which will prevent calling a\n    `dispose` function in the case of overwrites.\n\n    Will update the recency of the entry.\n\n* `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\n    Return a value from the cache.\n\n    Will update the recency of the cache entry found.\n\n    If the key is not found, `get()` will return `undefined`.  This can be\n    confusing when setting values specifically to `undefined`, as in\n    `cache.set(key, undefined)`.  Use `cache.has()` to determine whether a\n    key is present in the cache at all.\n\n* `peek(key, { allowStale } = {}) => value`\n\n    Like `get()` but doesn't update recency or delete stale items.\n\n    Returns `undefined` if the item is stale, unless `allowStale` is set\n    either on the cache or in the options object.\n\n* `has(key)`\n\n    Check if a key is in the cache, without updating the recency or age.\n\n    Will return `false` if the item is stale, even though it is technically\n    in the cache.\n\n* `delete(key)`\n\n    Deletes a key out of the cache.\n\n* `clear()`\n\n    Clear the cache entirely, throwing away all values.\n\n    Deprecated alias: `reset()`\n\n* `keys()`\n\n    Return a generator yielding the keys in the cache.\n\n* `values()`\n\n    Return a generator yielding the values in the cache.\n\n* `entries()`\n\n    Return a generator yielding `[key, value]` pairs.\n\n* `find(fn, [getOptions])`\n\n    Find a value for which the supplied `fn` method returns a truthy value,\n    similar to `Array.find()`.\n\n    `fn` is called as `fn(value, key, cache)`.\n\n    The optional `getOptions` are applied to the resulting `get()` of the\n    item found.\n\n* `dump()`\n\n    Return an array of `[key, entry]` objects which can be passed to\n    `cache.load()`\n\n    Note: this returns an actual array, not a generator, so it can be more\n    easily passed around.\n\n* `load(entries)`\n\n    Reset the cache and load in the items in `entries` in the order listed.\n    Note that the shape of the resulting cache may be different if the same\n    options are not used in both caches.\n\n* `purgeStale()`\n\n    Delete any stale entries.  Returns `true` if anything was removed,\n    `false` otherwise.\n\n### Internal Methods and Properties\n\nDo not use or rely on these.  They will change or be removed without\nnotice.  They will cause undefined behavior if used inappropriately.\n\nThis documentation is here so that it is especially clear that this not\n\"undocumented\" because someone forgot; it _is_ documented, and the\ndocumentation is telling you not to do it.\n\nDo not report bugs that stem from using these properties.  They will be\nignored.\n\n* `setKeyIndex()` Assign an index to a given key.\n* `getKeyIndex()` Get the index for a given key.\n* `deleteKeyIndex()` Remove the index for a given key.\n* `getDisposeData()` Get the data to pass to a `dispose()` call.\n* `callDispose()` Actually call the `dispose()` function.\n* `onSet()` Called to assign data when `set()` is called.\n* `evict()` Delete the least recently used item.\n* `onDelete()` Perform actions required for deleting an entry.\n* `isStale()` Check if an item is stale, by index.\n* `list` The internal linked list of indexes defining recency.\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most performant\nLRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In particular, the\nperformance of set/get/delete operations on objects will vary _wildly_\ndepending on the type of key used.  V8 is highly optimized for objects with\nkeys that are short strings, especially integer numeric strings.  Thus any\nbenchmark which tests _solely_ using numbers as keys will tend to find that\nan object-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is unsafe,\nunless you can be 100% certain that no other type of value will be used.\nFor example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage collection\nof large (especially: deep) object graphs can be incredibly costly, with\nseveral \"tipping points\" where it increases exponentially.  As a result,\nputting that off until later can make it much worse, and less predictable.\nIf a library performs well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large objects as\nkeys.\n\nIn general, when attempting to use a library to improve performance (such\nas a cache like this one), it's best to choose an option that will perform\nwell in the sorts of scenarios where you'll actually use it.\n\nThis library is optimized for repeated gets and minimizing eviction time,\nsince that is the expected need of a LRU.  Set operations are somewhat\nslower on average than a few other options, in part because of that\noptimization.  It is assumed that you'll be caching some costly operation,\nideally as rarely as possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys, and you can\n   guarantee that no other types of values will be used as keys, then do that,\n   and use a cache such as [lru-fast](https://npmjs.com/package/lru-fast)\n   which uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric strings (ie,\n   less than 256 characters) as your keys.\n3. If you know that the types of your keys will be long strings, strings\n   that look like floats, `null`, objects, or some mix of types, then this\n   library will work well for you.\n4. Do not use a `dispose` function, size tracking, or ttl behavior, unless\n   absolutely needed.  These features are convenient, and necessary in some\n   use cases, and every attempt has been made to make the performance\n   impact minimal, but it isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data structure\nin version 7, yielding significantly better performance, albeit with\nsome subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or before, it\nprobably will not work in version 7 and above.\n\n### Specific API Changes\n\nFor the most part, the feature set has been maintained as much as possible.\n\nHowever, some other cleanup and refactoring changes were made in v7 as\nwell.\n\n* The `set()`, `get()`, and `has()` functions take options objects\n  instead of positional booleans/integers for optional parameters.\n* `size` can be set explicitly on `set()`.\n* `cache.length` was renamed to the more fitting `cache.size`.\n* Option name deprecations:\n  * `stale` -> `allowStale`\n  * `length` -> `sizeCalculation`\n  * `maxAge` -> `ttl`\n* The objects used by `cache.load()` and `cache.dump()` are incompatible\n  with previous versions.\n","readmeFilename":"README.md","gitHead":"e92da0a6af50a6f181eeca48cffaf266e2dd10f0","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.0.4","_nodeVersion":"17.6.0","_npmVersion":"8.5.3","dist":{"integrity":"sha512-2kmlhulWWdRsG+ELcVC94Gs0MRurw6Y5Gh1EHMzbYnYkXeqNHtGg9PTjlcmnT+gxcihwlYwjJ+/gYQl37hMV5Q==","shasum":"505f3e1dc5b2c0189bff238a1b98dfecfc4aa8dd","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.0.4.tgz","fileCount":4,"unpackedSize":29758,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD/2ULncTBQFof5SPU3nFYJ1OLxdRA04quMqLHutFVi8QIga9p4O/FgcyUyx4VwgTXnNoJAaXOWjxmBNi5+oPxXEG0="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiUeIyACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmptqw/9FQjS+b45ECps5qMEnhfH9nloqBg8ewiIXHIrVws4MKDzXgbC\r\njg4YTGNYubE+Ei5boHAb7XlSqXENBo9K/qmSJSjMCdnuUK7ArMCDtpgvjeJC\r\n+msfA0ohBeh2BqLhxsVgmEXhfVkmQCZRL2uaUgLPpqEDXHiEXlYxZUyTclXw\r\nmSfH1HOwqQhFbG1pIhIzeJKRVtcdXsUw2GkyHCo+ZvLRU5GZWClSNj7D99W0\r\nQw7ixABMRiNHEnkxJat07B1Gvdz4f1f9o+6Eo/80Xww1mhVCJnTcdZysIRsE\r\nSD3Vmf9czeSfXKH7QhzNmmITonP0pBxiYsqusWWAPT2Fi7yEZrcF6W4vhpnC\r\noOH8bMc/S5E7+iQ4ckWDiFry4qdSE/C9+v7W04wlC31blR/3CiwYWIO6D5Xa\r\nUgg5+QcGxYXbpqOmm+ux0zY9IN2X9C8F5RrjZ1KB3xDxO4RyruE6WU13trg/\r\nMwdV/N9ReRINZBksawbs7bIUk3oRNQK4FNXra5NFAeTKQmJYjFIApUi+D4cv\r\nDfc7owH6/5akpaXp12503c5rvG60SbYyHExHIxCD2ErGQVGh0opMB1N8Dbbh\r\n9RK3JB4Fb3fvbIp2k/IzQ5LM0vXxap5FrmEeRoG+LD4NKrZVZGE11jpFzqQN\r\n2SLHNK68yBCTpovynRzj4jXlfO48C0FUAy8=\r\n=w6Gz\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.0.4_1649533489992_0.1583613736748093"},"_hasShrinkwrap":false},"7.8.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.8.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"gitHead":"e71778502d324b79c3c304ce70e96be3b4cfdc49","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.8.2","_nodeVersion":"17.6.0","_npmVersion":"8.8.0","dist":{"integrity":"sha512-tVtvt+EqoUgjtIPD3rXSJCSf5izSRJShgnzUeK59T+wxZ9LrFEP3GxhX/Mhf8Rl7kk4ngd4vZaV+5sEibhvQ+A==","shasum":"db4d3bbcc05b2e7a2ae063f57fdb42d8d45f1773","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.8.2.tgz","fileCount":4,"unpackedSize":48443,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDpkucdX8s39ImIT0l2fNCnArXNuYpB0D6H+jckX5yhAgIgZWesZO1ojlJfa6ZbJnVXntsy3akyoO1K5sptlEZnRqY="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJibKKEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoO2g//WVLZBn4cx2FiQuVKwpqKSNji9e0kbKejhRTdehWke+tSw49O\r\nNnOiDRXAFy1Unu64KaE0Ge8FdBuP+PTyjy/JoNObk5r2T7e5wxmeb83fXFem\r\nk9GQMTaknHopIe9CT7b7nMXjyDo8BtU9cvFpJZ/8AVXzYyB6IQAI0blPwLlc\r\nB7Q27fltM+mutjTHLBrwsnYf2DTsln9Q/Ofq/61W1jIKZOUzzdMekA/zKK0A\r\nRLV6JfR4/oEd76qP4GjdmMWxvVVfgheGp7yUMMtKInV1nm9a79rhyp6yz7Rk\r\n5liRzjxLW3oN2wPEGwrq4RIccqnxIV4UrDAkMbwbaQrqRJKt8cjJLQ4E3bjD\r\nx+eVNBooEJpPVDDr8xDAHUrhjTrRen1Ja9DBF6eNAywdk1MLI2wHWGH3FVKO\r\nAKvGX/cZDwnvxT4aXVhHfQRwKZ/ycWvOjmblKPnae4UEgdQgHCjRZ4/MKF8/\r\nwpgOTLZND92R0Lddx9QyPzgboB+n3Lmt+4jHPiCLn3XD76HNwSAv5Wq/ADJ6\r\nzGIE/9jubjq3aOh/m2So3hMt68Dr1uJhBqZt6FJaUSn1FJZdhKRLwaphGdOt\r\nrRHHlfsjHoqUBTwjSYThfRSAXElt8NG7naA6z3RnJ3Rf59rnOnms85MHNnwu\r\nk5BXOYVzrd7qnxjzlcE3IP7MAYTGs3ZJkEY=\r\n=EpOw\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.8.2_1651286660471_0.8601136598219326"},"_hasShrinkwrap":false},"7.9.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.9.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"gitHead":"892db2226254df892af461a272222cc4d61454b3","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.9.0","_nodeVersion":"17.6.0","_npmVersion":"8.8.0","dist":{"integrity":"sha512-lkcNMUKqdJk96TuIXUidxaPuEg5sJo/+ZyVE2BDFnuZGzwXem7d8582eG8vbu4todLfT14snP6iHriCHXXi5Rw==","shasum":"29c2a989b6c10f32ceccc66ff44059e1490af3e1","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.9.0.tgz","fileCount":4,"unpackedSize":49591,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHxvKuZRSs7BQKhmE/Bz9Lq/feFw1BaNn3gvF5vbOrBuAiEA09RjMQLW3ulQ59qPF9yRdb7gD6Lf4KBQZcQ+A4tu9nA="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJibMAIACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmorVxAAmfdiJ/Ajx5bUOt2qLmT6WbmIQEIKjUbDv8T7rwR5Y1mKQQSa\r\nBi3mUDcSUtIvHjv+dZVSOk4E/zjOdDAns7ciAzu9mddKl0bRGVLJYCUqzex3\r\nzmz3NQUB52BBHKVKUiTXnTRpZB9NTEf/yfEMFykI+tvAE7ZsfetwsIDT0rdt\r\nwM/63vKOPK+zNAOXEF3yggznc6pZdhmINOc2QjyYiVfGRrTEy5v3msAsmUrv\r\nA1ewG700p8Xgnau5irrFxTlqKP8RMBrNoV7wZo/EdwseJiJnL6IpZlMYJj4V\r\nGz+pjqCx17LV1tNPLmEwY3YeBEqgPQCt8Z8z7DBcIFPWCDFvQWANTImyB7yk\r\nBs0D3nIqJP8w88LHoetYhsMAyryGZiOxcEd8yXEhYMIgEhTjVSwD65Xh/ExW\r\noXqM16sCRyZ+zQYc3PCwmpPme4H31JPLbwbU1ITc7tk+pHpFlSXu7F11W2YH\r\n8p1kRfv4uDAmkkbEBksSrYQMaM2RRe3IGTmEHIC9TPMbolU+8IRpvie/fJIA\r\nro4PEuuUh0+XMrtHx/Mgc+N/NjJevpdpJbuRRFl+b9U1qsg6oNzZ2OhhCiaq\r\nOD0n3IJkW9HD/+XUOgm41y9x3cnbCdO5KWA7LMDocN66DxrmLkcxtdPkyob2\r\nDmGyzLUPIaINx1ddqpoEhHaXJC8o32W+tBI=\r\n=T1Z+\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.9.0_1651294215860_0.1613350285048809"},"_hasShrinkwrap":false},"7.9.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.9.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","test":"tap","snap":"tap","size":"size-limit","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags"},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","benchmark":"^2.1.4","clock-mock":"^1.0.4","size-limit":"^7.0.8","tap":"^15.1.6"},"license":"ISC","engines":{"node":">=12"},"tap":{"coverage-map":"map.js","node-arg":["--expose-gc"]},"size-limit":[{"path":"./index.js"}],"gitHead":"32e7912b07c5fe68c8ed8a32d7795112eaf4ac50","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.9.1","_nodeVersion":"18.1.0","_npmVersion":"8.8.0","dist":{"integrity":"sha512-ZPHK6KZ75hO+eWpXJD7dH0V4lY17SDyRvRdZteRpFt4onQoAV5v8VyZMBjpEwOG5ZZT39IczmIv5nzqLGA5CTA==","shasum":"f1e19ff47b4815aa98ef16d7c30024c1e3947da4","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.9.1.tgz","fileCount":4,"unpackedSize":50012,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBON8gN6cAR2FchlEAQVb6Z2v3MPZIRl1HuLVVGbxiIJAiEAlkPcj5KBAti8K7f2aoA9obOWWI4WH4N5kn+ev+ZfXEE="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJifA45ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmog8A/8CqYw1ARiPl2bXJHKtCVYTNeNCfjgoPFaMhGSeY4HznCjigUv\r\nqLGZL7Ra+P+hZqgJgQ+PbD9jooBFt2xu2qRcGItQRuaifZ3hyDiqY+XNUCnH\r\nZkskhmmeb+WgCDscpKvyn6Q+ZrkTW7QxFMVPWCiqqp+jLpyrrrlvaKztwUa3\r\nu7Qwr1vVIfdrIBxTd5MFA9kHVES3AQS3aad+J2rr7tHqRLc0RuSqG8gw0tIB\r\nm85P/D2bZo0O4pWq/P2x2VkmF6/GuFyjErGH8G6/8ntuPnyCie+FLVjt5XJF\r\noAUNR4e6AzNQEXJsn3Ca8HkzIQOJoB0vwhwYsXuA0c4rCbNdJmGoShJsTXsO\r\nB3O9nwhKC1z9ehPyCq4lEcTxnqTEdj4//ARIPzgg+b176TdsxJN4Zb8NvrH3\r\nhtLBUuJpdRmy7eyEyYD0e/AxW2GKR8g8HL4RlndmHpaTmXlrEhz9Bn7/Zek5\r\nU+TQR7qFAWTGnI7LFM0xfzWi79K52cJSTMlpNZLRBVT+h64lbm2kFibIYGgF\r\nOtZ5krIVtocYfWe1lLbBS4MunZwZogmcx36qYs5Z0dAEvfEwdW/G7x0MIM3q\r\nZEbeFeY2bKKnaYesUcatXiAPbAYECPwKTFgjr8FNE/jWKshcVlaOpKdeFAMU\r\ncsdC+x25y8Eapw0aXYLa4eRchjhWlE01MxE=\r\n=18r5\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.9.1_1652297273152_0.3353799908560604"},"_hasShrinkwrap":false},"7.10.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.10.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"c551cbf795fe5d7a19ad6786f71ca9f36f08f4cd","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.10.0","_nodeVersion":"18.1.0","_npmVersion":"8.8.0","dist":{"integrity":"sha512-mk5BXponDPbfvGlRuKBlh8YefbGXg61gUFunI/z78Cl+XXUgEs6PSvyoKVjfGLwT79Rk1V5w6M3w52p8eBm61Q==","shasum":"db87bef52eb5036bd66f7f9c32cd1d614b5652e8","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.10.0.tgz","fileCount":5,"unpackedSize":68668,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDGEjz5RYbZASjgF/4VdPImrXtQ8ljBIujg2C+2AYGYAgIgJ0ZLcCXZTF3cy4X0OvW7NLmDAjUsc/oMN+09YdMkmU0="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJifA8yACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoRpQ/+Ipj9EH9qUbmCLz1shGpID4A9kksySX1mf9yYV+Wfd8Zy/KCP\r\nT2XVp8f3fndmyEJQvxUcZisSAfX8Qg71yScoNyaZBTRiOQO81GkiyqpF9TKX\r\nwNFqRUF2Mm+ExO+RIpaHfdfIFOt/nKAQaarMy9r5rF6Cva/xnuOOEDWBdV1N\r\nZGI008iGS3PsXV5+j0S+G93GgfGCKWXJeedmwIPB6O2bUB+E/OVGvsuZmQm6\r\nv6IetP9HiA4OrFE2qj117UK3lvf0701/yZZYO+uR0jFpRO4pZ1a1rK5Q7hB9\r\nd04j87X9ZBdwh2PXCIHei33rcwHi6PosUjsAxRPpvpelmWEdG+xF5ZAErt80\r\nOd1ttMva5JNgi2czbeoeFeU9J0e0ZOuS6aO2oUe5YRnU8jOzEA4ekujXEJtg\r\nYrpjlB1/+yDwOML2yPGKgEVLOyD8bhCsWUSBsRoI2rgVEJITOr9n78e/AQPo\r\nuxVVt0B4u/XF1SL5MZ8jRqadiCWfwwQ+O0Ue4qLMkumlGGiLM8muOqJH00xB\r\nHutcnA9sHodQl6bUPCIwYdKBF+w2qrv85A6SQn6PK6f22SDISF2omqO1psSr\r\nETsRrUZHj0OUSCT9smL+zsGrPOJTLBWnm84meQR+tu4c9X6FOc66bVmEbeXd\r\nXaJ5BVAdNiJn0oJ0rmyENCu8JS35DmMVkmw=\r\n=U9Y/\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.10.0_1652297522418_0.6961966610383523"},"_hasShrinkwrap":false},"7.10.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.10.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"b486515795a4f245f65d7425363486f33f2ed7bf","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.10.1","_nodeVersion":"18.1.0","_npmVersion":"8.8.0","dist":{"integrity":"sha512-BQuhQxPuRl79J5zSXRP+uNzPOyZw2oFI9JLRQ80XswSvg21KMKNtQza9eF42rfI/3Z40RvzBdXgziEkudzjo8A==","shasum":"db577f42a94c168f676b638d15da8fb073448cab","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.10.1.tgz","fileCount":5,"unpackedSize":68731,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCnw1Bn2yqDe/3ntgfkJ/NUkwVpF5I+cMlwHTt6g2bFZQIhAIpz5jwt+63CMN+I8MN5BR5XNHlxDffgXVGaWzSbPnvh"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJifD4EACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqp3BAAoNLwWp+PV51DdzcTU3cA9GDjoJqDuHWBeakFb8q/Tk3juWjw\r\nDEc/Wttr/ZE6G4N2jPDx+93cGmP/N+jRwQEZpNprK46jSkgk0hvYmS6fwhva\r\nU0m1eghwccj0LuE2jUVdRbcsTS6EWPYQb8OcNhL8i+/H6TfL9RKLnhFgJUP3\r\nMqFERiCtLubmPoPbmEsoiPdYHUR09TDSPNKW7qRm2a+3xnQoqSZjMaYDMlkL\r\nkyuqWaSC5+eOpeJQXQ/vrtFtW7nEpvrg8Bqb6E7UZf5CYtOPLxD3zRbGjJCU\r\n8VNa+lWoTbBvPAW1nxMkjewuwDdmsQLm0a2ej/g3qd9C/3CCfjucNlhv328Z\r\nL5wHy6vLyllgT+trZDqwLEMyfsZU5IbZkkiOklfDTOdXooYfv05Y1ysMgwYz\r\npxiUcGmEblE471xze1haT9q4WJmc4faZ38QJprbmkrqwZ9rDBhf9zzv4jtBX\r\neXpe28iB8YbirTZDat1AfC40CTkqMO8zO0vBdbmMB9ZG1669CobT3U1dtV6H\r\nSWYFfztPsf8h5pWIFdRM9wiZk7e3lMBZev7GIh4vssl5wDPBnNgcg5U8p7bm\r\n0sV3YWsxUV5zVe1gDanfx5UW4VKviTp0IN0b/En0RrBiOHRzZAT73ERxVrIL\r\nNooQl9nTfRu0N3CTToMFMYpCJZIu3JUbLrM=\r\n=hgnT\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.10.1_1652309508275_0.07397421288859918"},"_hasShrinkwrap":false},"7.10.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.10.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"ea673da69acb3b5c2c105f2d174dca2f7480fea0","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.10.2","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","dist":{"integrity":"sha512-9zDbhgmXAUvUMPV81A705K3tVzcPiZL3Bf5/5JC/FjYJlLZ5AJCeqIRFHJqyBppiLosqF+uKB7p8/RDXylqBIw==","shasum":"aab494e0768ce94f199ef553ffe0a362f2a58bb9","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.10.2.tgz","fileCount":5,"unpackedSize":68945,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDBPZN9J+N+uLTdTwvHF1WoUx80P574/ecXPO3R3/zeZwIhAI+1U9kRMWTcTE4hQSQcNj8twXkFK3Fgoeh6YqeL84Bs"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJitOmYACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpvJA//RvZxEUfyehmIJ//m55cIwuVRmzI5c7dNvDY9OBBAM+hijp4q\r\nlxGTc/AtHHq1el103rsOSrTQ520ZySx4xYA81g0h6O3unM2vqZ0ImAq/fua5\r\nKpObvDXMM51l6o7a+C35+P/HA/UDHakmgdDiUjkceMqXUdCpj2eEY0yBHdhb\r\nAUdVBHig7nQO48YaS+diqs6wir9LO1z0/lDiVNHBiAMdS76Zum8JtCopydrF\r\ncTD9YUslk4tK5GJdlNms6XZ5imrVZ8M5yRDhOxXeHPPYXRFZH/mJh6FS+BjT\r\nLbZr0rkfz01KQlKSAhx3uFGiKQC134BuPqccnu+TwF0E8+ULfZZrxFy0nxh+\r\nUzek33AQB+NkP5Vce4ShQmDW/4Rba5lUVGkdGAJ/81BH88VVkfiMGigdYc+5\r\nPXMdTGhkV/aIwlurIkrt09YwYl5uIa3VAr1KjJGmFE9v83SCt5RwroflvrkP\r\np0r2EjBYmSa5ngec0gd0oCVcJHx0Ei1r9WGuNCgCifBvfXfpsE6QI1rVq/Nx\r\nHhmCQYr3ME0QhFw9gkMD33bXV6EI1eI+W+a0zHg6cl/xU8WOVvfjGP5IIhkP\r\ntVPftyd9z+wxiXIDiRiJoiMhy9kgOJjwkkHlBfa5qJiiGL1fEUjcxk6mCLjx\r\nahtteswHwCx0dwuwzFr4Z80h8DCe8zrCZv8=\r\n=1WlN\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.10.2_1656023448274_0.3368364984252705"},"_hasShrinkwrap":false},"7.10.3":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.10.3","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"b9918def87157ec802c5ebb2d8c53f5625133481","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.10.3","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","dist":{"integrity":"sha512-y51R1ks7W1/LXKf7gPUKFB08aJakxfHKNp/B9d4jdMtryARTFc6rtU5LCdIS7v4L0ZAJnGzAAXfFI1deF6pDTA==","shasum":"8c0c42c48cb145a1d568fc288377e8d75c528bbe","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.10.3.tgz","fileCount":5,"unpackedSize":70238,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCgKu+VT9a9uigDaAGiDaM68Qs//6c5WEr9O7ix2BOGfgIhAIt020mJQUCVwp0uJQjHFgOGN+pmvTNZe99+IaMdoqvx"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJivKW1ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqkqg/9E8QxFFa4Z25Z3C91IZ02EvxgpEvBkfNgqaeMJWk3/jDyWnr6\r\nxE4bo9O5WevCw8BLlqT5QU54hRlLFrmermvSEaybutete91SstKSr8bDkHlZ\r\nTfibxWXHa7xwHCjT+73b9AR2nluXS5bM/yKNEwa2Zb4C1vZ9nLKhl8Gbp5cp\r\nJusguE3u3aAD9MDNrNujSCx/V4QxyuGQWUubN/OcQWme5Ii5yzIDSR29ETVW\r\n4rKlWtngyg9meBmT3QpzQ0G0xof43fwNLVEc2Wl1UM5X9fD9xNSHU2KCOOX1\r\nLS3YoQATkuznzdcTHkjhGcL5xH38S4UNpjBg4S4hdYZBz+e4wa/viN+Z/daL\r\nLwOZ/7XsA5J2gi2WRYG7GmspYwQCr9kQWFeXvoje8aAFiqNrDq5RRSSUvGx/\r\nxZJJyIB4XoqR8a1i1Y9zm7v6gsvERCt6f3QABgUtuXkUTT7S3UT+IYmxY15m\r\nh1y+tYV9ufL3W5Oho0TPb2u4hpuJ9Z8CDz0xjyK8v8jgTmDI/6/xUzFuh8+Y\r\nfJYgUQr4KEJUxRIoTirr9EO5hKg+6eab3SpHZck3WMpHLfLgEJc9d6KspF/J\r\n8YtqhY2QIc+dcNS4PS2DY7V03HCMy5MZ2ZURL8j1kVYZIJ28UD4AJa5jsXd8\r\nwLcErG0LiXIGCM+GBfc/OE7ivBAJ6FFHAnw=\r\n=SSBo\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.10.3_1656530357449_0.6084094548930938"},"_hasShrinkwrap":false},"7.11.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.11.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"118a078cc0ea3a17f7b2ff4caf04e6aa3a33b136","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.11.0","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","dist":{"integrity":"sha512-cMXDHMxwo6Rv5Zdv4ReNNSpRkCTCRRV0JGGTaF3WN3emk0Th35YNWr+U645hjvh+RxjwifVYoJ6368fKHtVBKw==","shasum":"e8e18a08af9c2af3fabdfe0cc43d24aed94a5f3a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.11.0.tgz","fileCount":5,"unpackedSize":71433,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGij/ITmloyohVSOvLTLOckOjUojRBYhgpbgxIWClo/MAiBipmsncmUmtUQ8zaM/z2aPq1L00Q5aKHLk03TH5lT7kA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJivM0PACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqwjQ/+ITtbpTkHYwZ7FA3etH1Q9d1ekOAgM3zhVDA/V6FP5JtanF73\r\nU/ZHXZsKaQAW03+wArxSeWDsjHOozcvrtTFHsI4AYQibwPBoqcxm+FbTJtWY\r\nfNfRfvpvdoks8UO07aC7gzL0lv2m69SmEsLWIHomIh/3KPte7U8DcinvTNJq\r\ntLgg6h3srDUpdwAA6t1N4n3HJWhy6HNFKlaDkB2vZ8KCGsRiQYZpS8A4CDj1\r\nuPV73rRjMn5zd6rmklU7WXTV944W8XCf3YUz/VpA5Z1mgJE5KckZa5NGA/pf\r\nNdWRGLoOraQRBdXwfs/SjM53H8OZenxbkYmoN+iAT2s45DkS1CppdYS7/9XZ\r\nwKjVk9uuozVoe0I3sdy2ySgEp9atAptk19sFxpFW1rxqJP5CguKLh8iseysP\r\nwyW0uTEmb+bPTAJYbFlTJcpx5tqPAHwPGJnzagyF6hiRJQp+4q5p2hZ2VtZA\r\njH4YSM9IXMMLyijo6EmpRIdT6eXRdjB07mLUNuhO1OAL+0TvVTjW/Hy4lKpw\r\ngUbqfdhRGkB+WfLbXBaYUOmR8EUjUTHBIQIbvwiiLEE/4mX5EgPHufMmz2TY\r\nVJLfJ4ts//9bk1Jhuk/GudvoeaVE1I0DKxGtqpIokanHRH1WnfvwircIcWz7\r\nPs6PQYM5l0MLo4nKs12zc1wYodOam72GZl0=\r\n=SCAX\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.11.0_1656540431667_0.247888844518644"},"_hasShrinkwrap":false},"7.12.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.12.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"7ef678e4548992a8640ba5dae35f72590f9eba7e","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.12.0","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","dist":{"integrity":"sha512-OIP3DwzRZDfLg9B9VP/huWBlpvbkmbfiBy8xmsXp4RPmE4A3MhwNozc5ZJ3fWnSg8fDcdlE/neRTPG2ycEKliw==","shasum":"be2649a992c8a9116efda5c487538dcf715f3476","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.12.0.tgz","fileCount":5,"unpackedSize":72557,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCft02IZqc3sP2q5bIAcgId65fxt776fuyso++2W08CXgIgSY7JouGHLidysst9UhSDWEPzoTu43KahxHYE3zIlTAw="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJivNVfACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpXlw//a3ljBz/5pwA/O2VLRJWDoebU3w5E14YJfEla5TzpSYWuC7a6\r\nfP/Xtuedg+gW0gPuTDXx5AUg6odyp8AAVqIlHEm6NkI6c1F/0cmc9kez/7FA\r\n2qZHx0ruLuBS2zKfAxh2mOcBykrf7jsy6N1wsqrqSuhDmv66Ed4RB06vZXfd\r\nMB4ChhfBtAmfCCsu5NwtFH8Wn79llT/qCmZqQxsxwL2Tzl3cVV441lTzEJu+\r\nkaGkGGOrfefaBa/JUu3AqDVldcszDmioFJ/WlvvrfzA4zlz3owaQX5keAgJn\r\n4MykehtFB8uSWRd1ltzNqcfitwf7MPyEHHoUTcoRed6eC6qWNSCNpbX93Z2z\r\nga+FbiEp0nks80qNHsF+DMDEFMQMVQb/HrRhcirtgW/ZtdDIsJgPuEicNJtO\r\nMinAglsyUBN2RSPXcFnvl+MYFbp6f1PTgMk2i4jyjXxyrEj6j8dWAwEmRBGK\r\nsOyafMjxhdLPT7BkvctKecKa+yk+zZ78VEY+RyLcki3keWz+aDjMrXQxNs/l\r\niJK+24m5J8N9Z6ZzfMG+kUqXsfpUhDq7fJFxK2pxYq1ktDzMy9DXKGtqncmi\r\n9f/UoEvUuj0B0MsMVc8JfU0YLad+Lxy3mOGoFVrQtRt9bBoEO5E+EhCaYkpV\r\nmdYA27WE3oQDr8TkZLbHVLI3fiSpzIvPzSQ=\r\n=Z4QL\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.12.0_1656542559256_0.3493810587319208"},"_hasShrinkwrap":false},"7.12.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.12.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"9e48f892bdb8c0f8e640094ebce6dc59833b435d","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.12.1","_nodeVersion":"18.4.0","_npmVersion":"8.13.2","dist":{"integrity":"sha512-qYiZKGl80IiaXkBzj2dZ2JqdzgFKh2/MAwjAAE6KXG3wLIE2dYVdD712fAL++3dSsQGBm1QDJTegFu9p+fDa3g==","shasum":"c8df7cabbbf9aed9c3a910c39da74f984a5eb53b","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.12.1.tgz","fileCount":5,"unpackedSize":73095,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIECXfamNOSMfYcpQbns9dxkARHNyALMFpQJtMi1aQPkqAiBAoyE3h3jYC41ZP3oYOWX5prZ2RTkvLjcP/JBZmzbwAQ=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJizf0dACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmofMA/9EIva7ia63bwq5k5k7USm1X1+bnGAdGA985d3JTTAhvQy8Fg/\r\nm+JToCzXCZlqGayGV7HaxgZwNwMxZvAZ7xUAM0kTXLT4WCFFglrWobwOWYOj\r\nXsyq4Qqa9IvJDh7kW54mObvzLs9Bp420vvSD47PFzxwo3ArC8p34GUBIvwkU\r\nVK42kUZyUXasTADx4r2vlLoyiLe4piMAh4lrX+/OQmQUM0dDOfMmgac5lHy9\r\n3YcJxR9lOARsF71lYf3//d1z9+5h4PLs2Ntq3u3BV49EEW9idPgbn0/a6EEd\r\npmz8E8YkyrDkWNNl3/cwt6sqeHcjUl822uRBGFRxyfGrz8lOxP546x8J1/ig\r\nNXowIpAqoHvGCJRRFiMcafC9TFCR6K5nfC/KKwCiSf8hsHZfZvcDI1oSZO3Z\r\nmtAnY6BJTNNgm+GX1iK3RVmi8GRwGStgjwXMUl3i928eljNG0s1vSvJNPDoH\r\noCINsAa94Vqh+OCR6QpAujOSFT84uRk36KRaQGltr0falsP17t1rCnQ21apz\r\nca2AEil3qGq5Q19t86GQj12ZNGsheUK2KcAYIWADyUsoh4FJ4o1WTuww0+A3\r\nO/Jx7SJxGeKBXroDS8e2AXnG3URRiEOAp5I7GmmlcIX9X0UHESmjjOYgPQ+h\r\n7ai6xnzeXuFHqBGbshb0VAWXolLACIXdk0Q=\r\n=OcXP\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.12.1_1657666845109_0.6798962179611703"},"_hasShrinkwrap":false},"7.13.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.13.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"c028709c722214603a423860f855d4ca9def6141","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.13.0","_nodeVersion":"18.4.0","_npmVersion":"8.13.2","dist":{"integrity":"sha512-SNFKDOORR41fkWP3DXiIUvXvfzDRPg3bxD1+29iRyP2ZW+Njp2o6zhx9YkEpq1tbP0AEDNW2VBUedzDIxmNhdg==","shasum":"c8178692969fb680cad948db4aad54066590a65a","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.13.0.tgz","fileCount":5,"unpackedSize":73732,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDyM6hmG3zzrEaOq96Eb8CHtYw+BRspd4Ev4bcUtBru9gIgJBMM/tyOSiGA8eTcLyZYvU1LcKhuL39SU4aWqZrK2S0="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJizgDcACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrJ7g//azdKJ+feAa5BnbDp9vFk501wxdVPp++T/NYB6apXzybC84kg\r\nVz77UuUKYzeE8mNguLPH63NQVy3gdCLdUf0xcc49YVOhWhA1k5Bia5KZnydO\r\n+USZ5iTGHl3dnQasTzeSRa8vJ0gXmiQUKg0LH1gQs/WcQd3d5cOFPpGE4LtR\r\n13dPieqACIRgXrv+HQYvkFl9RZ9oVKNRaQ7ux/0ciMHQUWF1PNvWAJSmPEmm\r\nVzHA580+BCZuFYd4EDGH7zyq+XqbZMlYCeVcodTe2p9hrqOIQA9h+n2oszA2\r\nJdDQlVkwzslR3EjtrtzQ9Ysq/HAXIZLNko/6BSUM+KQWNeoZTpi48E3NQ6SL\r\n3By1YwazkFtAVWRsMvioGHbuWCn8+Vi3GWLD6pea6GevCYwm9v6uUNqCOkFB\r\n41jtyvJFAUs1/dEjUiVrR0uSD3jpfOAlcFG0NdTHYhzd/6Hm7up+CXIolMiT\r\nf7Dx1kSlkRX067CSnw4Nq0Bds0xGasA4hq3XNiPx4PdAIpHpKRDB5wwCDI3a\r\nZtCbe+vUKJATccjvcex7dm7L7L1RZsjiXI56NtHbraceSt0HcQSD1UPfkNVs\r\nyHQU3uG6ljC19oPUElkJ6+qDftTSwrailM3K50OrEQEJWc3pqPZqf2zr+5Lf\r\nuIzvaiTnagfjtyQKN6L6uSXlbmXUbB1zvco=\r\n=FMKG\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.13.0_1657667804110_0.06700403111055775"},"_hasShrinkwrap":false},"7.13.1":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.13.1","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.4","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"92b35ae6e8c2e6abca87850591d8eba67cd3e26d","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.13.1","_nodeVersion":"18.4.0","_npmVersion":"8.13.2","dist":{"integrity":"sha512-CHqbAq7NFlW3RSnoWXLJBxCWaZVBrfa9UEHId2M3AW8iEBurbqduNexEUCGc3SHc6iCYXNJCDi903LajSVAEPQ==","shasum":"267a81fbd0881327c46a81c5922606a2cfe336c4","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.13.1.tgz","fileCount":5,"unpackedSize":73878,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDzy+mqbCu4mEiDuNU7VJlN896gwkbuVJdKTODIrvCR/gIhAOZEy1gxegAMLGyb6vIQbY9b6rqFsiSWES/XoLx9+iNs"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi0Kb/ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpI8w/+PHd95rcCDH8kygCmeu60LY4eJcxhTaQYIQJ6Zapzua4d+4MR\r\nSH9+13xS27bUvtbHdrs0QC1ct6PL5hOSMGDUXIVVv1MJaMSIsZWgnnAnMQJT\r\nDiPtWne1nnd4/BX+eihQsgIcOJXniDMOcZyQ8wSwv9Dk4Iv22S6qxB3rnez1\r\n4OANZI1o4PhFcwi5k8lpaFfvsZEWdapy9xgOA7eSZ/E+JNIXjwCBH9m191va\r\nha/hsXiyQTsC+t+q3U3EYCMyyoVVE2/MbyJUJydtR3+gZbO0aJSWJM0Le9ar\r\nJfJ18BU/pzWMM9DbtgHhgOqBTjJNGfVIPKIdqSY+X/XRX/GBMSX8N5/nFZ9i\r\nhj3fJ/6JLD4M5Nho5eMAsfLH7T0Y8+dVIKHQsRnHoY9pUT5WFg5Mui4hYdgp\r\nEDgAsMk2sHvkuX8MJ7NoyDu3itW45fF6KQkPXVVOSsfXiPNgxvbsXbyCJzgC\r\n3GC/TLzuowAPvapYZcPOKtJh4HLxB5a7sMqTFnVUo3OzW7Q+QfecPO/KqFoD\r\n1LE7crvRZ1BZQ4yh9mw0MdS/3Fhdqapge6+7aUwuqJWURKY6yYlFj0QqJ17p\r\njDSLHSUzMPjtdsUg8RUwECTam0tdtkZpFCv4O51kQj+nEzd3DAYfCv4h0kr1\r\nRPIVdS+N1Mh+Uz1Teywhe97ZBJsL7OuEGsA=\r\n=WK3v\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.13.1_1657841407172_0.9174413335644569"},"_hasShrinkwrap":false},"7.13.2":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.13.2","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"sideEffects":false,"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.6","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"661c8b78a47e4aa87604bf8a486070182f0cbf8f","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.13.2","_nodeVersion":"18.4.0","_npmVersion":"8.13.2","dist":{"integrity":"sha512-VJL3nIpA79TodY/ctmZEfhASgqekbT574/c4j3jn4bKXbSCnTTCH/KltZyvL2GlV+tGSMtsWyem8DCX7qKTMBA==","shasum":"bb5d3f1deea3f3a7a35c1c44345566a612e09cd0","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.13.2.tgz","fileCount":5,"unpackedSize":73833,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBi8r087FRe1/Iqo19JXIKSIsdojhDQSQj7gaw51R3paAiAeslq/6vKEb5f1917PI+XE6EhPofQvAkXNKA8L85w1sA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi6WWMACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpB4hAAhJIkCTplMmVwzn5RRmk/Xlm9zzZ389VKYIWFoeHtZRo8qlUc\r\nRfRZTlz6lewQ/TIkXWK72s8JgbSJ+vRP55J+VIOrq6CNUzMxL9IXw6aE0EkI\r\nELME7iULupG++S0voU8+GQVgPrAJPGyNPlAlda+dmBvGDtgLvF1e6vs1EC17\r\nyRYc/fKD9Oh8uX+8hWf4xovAUJBF3BJCKY5+086mfvCt3sjV2VQ5eGYBTsjw\r\nmqboOaWku7TEJCb/XteYQfSSI+aDYIhnKwzrLXNyoxspql2Z17bX8eTJ9UFk\r\ndSDI/kdjTmGkQs6AZr2W3shY1I+nr628pcqbnqthjNnKUUnLjPc6DeO30byc\r\np6l+WvbKAzZVQoRSUozdniGvwPEyPD5Ap9gBVwm/M2/v80QVTMvy+WpXIgVa\r\nMSlNuKsVxZz3LzssLUQe5D0sT73q/2Kf7IPI6tEp7mO8/L/BSw5ydQ24Xg55\r\nH58X5nWqg3gQu6WPAIRt8Db9E14pGdLSAJYIDJcMsIv4/IRpAJHAJXzdJFoo\r\n1jftEIEQ4Oieor8YVCW7CiMwoLyzPnaJhyvMalWp57Ac3WY8DQPvBiCKCeRl\r\n/nMlcujdwXwTxWkFiTdXjE29VfFphHZ5CONwMOZGKPcYim7MxpTC9t4DUTT9\r\nPSpcp1mGYNT9Bomm+zi15Vu7ef4G83uJgdY=\r\n=sFxY\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.13.2_1659463052668_0.21576298050212817"},"_hasShrinkwrap":false},"7.14.0":{"name":"lru-cache","description":"A cache object that deletes the least-recently-used items.","version":"7.14.0","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"keywords":["mru","lru","cache"],"sideEffects":false,"scripts":{"build":"","size":"size-limit","test":"tap","snap":"tap","preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","format":"prettier --write ."},"main":"index.js","repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"devDependencies":{"@size-limit/preset-small-lib":"^7.0.8","@types/node":"^17.0.31","@types/tap":"^15.0.6","benchmark":"^2.1.4","c8":"^7.11.2","clock-mock":"^1.0.6","eslint-config-prettier":"^8.5.0","prettier":"^2.6.2","size-limit":"^7.0.8","tap":"^16.0.1","ts-node":"^10.7.0","tslib":"^2.4.0","typescript":"^4.6.4"},"license":"ISC","engines":{"node":">=12"},"prettier":{"semi":false,"printWidth":70,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"nyc-arg":["--include=index.js"],"node-arg":["--expose-gc","--require","ts-node/register"],"ts":false},"size-limit":[{"path":"./index.js"}],"types":"./index.d.ts","gitHead":"97d1e2d780a4fda2b1ced1c40a7d9847a967e495","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"homepage":"https://github.com/isaacs/node-lru-cache#readme","_id":"lru-cache@7.14.0","_nodeVersion":"18.4.0","_npmVersion":"8.13.2","dist":{"integrity":"sha512-EIRtP1GrSJny0dqb50QXRUNBxHJhcpxHC++M5tD7RYbvLLn5KVWKsbyswSSqDuU15UFi3bgTQIY8nhDMeF6aDQ==","shasum":"21be64954a4680e303a09e9468f880b98a0b3c7f","tarball":"https://registry.npmjs.org/lru-cache/-/lru-cache-7.14.0.tgz","fileCount":5,"unpackedSize":74946,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCAZ4TPr6eLutJaKBpQ578924qNdb/4s2xN3GQPZSww1AIhALlHBouERZISVzbRKqp+T7kCXfJYn9hjsDdYYKS9Imns"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi/Ba5ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoeUA/9H5LuFKw3IdssxxzMjU7K3aEirDbWpxYCLW14lr4yEOkcStHS\r\nDQXCM5cXurK4Q72TQRRkpSEaAzFIaB62+IpmwtUY50kGFZjfJ2rrwAqU7VVD\r\n+EK9aY3/VDEo8J8edyABQEs8HsFULWcrV5H3MtOTWJ8Zv3umUFzLnsdCNauq\r\nFJOoe7JFh3c5xF7Vk6jJ+V2vRN+Sg+XScfnpsB+4zX2uQOyH35rK/T1nd7Rl\r\nK4ILc8fo5Vy0CGsMUe30AderiJxaYg/kC5VaN6abPRVOTXfvVlOdBLTEqTbv\r\nkQaiRf70VAUIqUKGaE2Xdkf0mwsWwvG9j/NbVkQagCDki6mfkHLee+lzvAuh\r\nxEmZ8Cr8Xj5J81rw5haKW8iTccJmr8WLkVB2fL9Fn6ED4zvKvMSLxyutb1zl\r\nrA0BLboKKPAVe4rn9wFyPVHxF3Hfr/mWx6Gz3JEnq0xZws0UtDEqyMVc28ie\r\nSEObHYpYanFEu01cviRFdrJWUIu99kvNlcOLnXScT9h1B9BsLO+/NNdZsJcK\r\nug3BHdyhoGhm5tfmzgd4Ylm3JgtLnSY7RfzmWDQzJf2tKdB994KK1vKRhNDV\r\nMCvE3uyJd3B+RVs56miKr91+3r/2fFXqW/R006B9LEW+gDU4x3NVaB5Uqh+k\r\n8z7TiJ+1u6XF5hfMenbW8QMpp5pJY6WiUlM=\r\n=mpl5\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"isaacs","email":"i@izs.me"},"directories":{},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lru-cache_7.14.0_1660688057566_0.9884912674901185"},"_hasShrinkwrap":false}},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me"},"repository":{"type":"git","url":"git://github.com/isaacs/node-lru-cache.git"},"time":{"modified":"2022-08-16T22:14:17.835Z","created":"2011-07-16T09:09:00.041Z","1.0.1":"2011-07-16T09:09:00.041Z","1.0.2":"2011-07-16T09:09:00.041Z","1.0.3":"2011-07-16T09:09:00.041Z","1.0.4":"2011-07-29T19:12:01.745Z","1.0.5":"2011-12-09T01:12:43.326Z","1.0.6":"2012-03-27T20:58:02.558Z","1.1.0":"2012-04-10T23:40:12.876Z","1.1.1":"2012-08-01T09:36:45.601Z","2.0.0":"2012-08-09T22:21:20.057Z","2.0.1":"2012-08-14T01:07:53.273Z","2.0.2":"2012-08-27T16:37:06.609Z","2.0.3":"2012-09-13T05:19:49.029Z","2.0.4":"2012-09-17T15:57:27.674Z","2.1.0":"2012-10-19T12:23:46.276Z","2.2.0":"2012-11-29T18:39:13.480Z","2.2.1":"2012-11-29T19:35:00.176Z","2.2.2":"2013-01-15T16:07:29.189Z","2.2.4":"2013-03-26T00:15:52.058Z","2.3.0":"2013-03-26T00:28:31.542Z","2.3.1":"2013-08-19T21:27:14.453Z","2.5.0":"2013-11-21T17:38:28.040Z","2.5.1":"2015-04-10T16:23:17.960Z","2.5.2":"2015-04-10T16:26:47.162Z","2.6.0":"2015-04-15T17:59:01.480Z","2.6.1":"2015-04-15T18:09:11.352Z","2.6.2":"2015-04-24T22:13:44.022Z","2.6.3":"2015-05-15T01:21:44.570Z","2.6.4":"2015-05-19T01:38:58.214Z","2.6.5":"2015-06-30T18:20:57.642Z","2.7.0":"2015-09-11T18:23:12.257Z","2.7.1":"2015-11-23T23:56:40.083Z","2.7.2":"2015-11-24T19:23:22.999Z","2.7.3":"2015-11-25T18:12:14.005Z","3.0.0":"2015-11-27T22:55:18.812Z","3.1.0":"2015-11-27T23:09:26.205Z","3.1.1":"2015-11-28T01:03:32.062Z","3.1.2":"2015-11-28T02:50:32.082Z","3.2.0":"2015-11-28T21:54:13.864Z","4.0.0":"2015-12-21T04:46:32.089Z","4.0.1":"2016-03-22T17:22:52.848Z","4.0.2":"2016-11-27T19:10:00.911Z","4.1.0":"2017-06-06T17:54:15.370Z","4.1.1":"2017-06-11T03:00:46.159Z","4.1.2":"2018-03-08T17:58:33.933Z","4.1.3":"2018-05-07T23:17:11.482Z","4.1.4":"2018-11-21T00:14:09.190Z","5.0.0":"2018-11-21T00:46:38.801Z","5.0.1":"2018-11-21T01:04:56.118Z","5.1.0":"2018-11-21T01:23:13.744Z","5.1.1":"2018-11-21T01:44:45.407Z","4.1.5":"2018-11-29T17:49:34.387Z","6.0.0":"2020-07-11T00:59:07.352Z","7.0.0":"2022-02-08T00:46:25.781Z","7.0.1":"2022-02-08T00:55:45.942Z","7.1.0":"2022-02-08T18:06:28.749Z","7.2.0":"2022-02-08T19:35:28.576Z","7.3.0":"2022-02-09T00:29:39.933Z","7.3.1":"2022-02-09T15:21:24.580Z","7.2.1":"2022-02-09T15:23:49.075Z","7.1.1":"2022-02-09T15:25:26.816Z","7.0.2":"2022-02-09T15:26:43.140Z","7.4.0":"2022-02-22T00:52:48.599Z","7.4.1":"2022-03-05T04:42:11.553Z","7.4.2":"2022-03-09T16:15:42.374Z","7.4.3":"2022-03-10T19:24:02.285Z","7.4.4":"2022-03-10T19:26:08.014Z","7.3.2":"2022-03-10T19:32:42.532Z","7.2.2":"2022-03-10T19:33:24.808Z","7.1.2":"2022-03-10T19:34:02.046Z","7.0.3":"2022-03-10T19:34:45.898Z","7.5.0":"2022-03-14T02:57:55.093Z","7.5.1":"2022-03-14T17:41:52.929Z","7.6.0":"2022-03-17T03:59:45.837Z","7.7.0":"2022-03-17T23:47:52.537Z","7.7.1":"2022-03-18T03:00:08.858Z","7.7.2":"2022-03-29T21:46:14.178Z","7.7.3":"2022-03-30T15:18:55.150Z","7.8.0":"2022-04-07T19:44:11.404Z","7.8.1":"2022-04-09T19:21:00.559Z","7.7.4":"2022-04-09T19:24:06.845Z","7.6.1":"2022-04-09T19:27:14.020Z","7.5.2":"2022-04-09T19:34:05.904Z","7.4.5":"2022-04-09T19:35:55.240Z","7.3.3":"2022-04-09T19:37:54.210Z","7.2.3":"2022-04-09T19:39:45.312Z","7.1.3":"2022-04-09T19:41:38.279Z","7.0.4":"2022-04-09T19:44:50.120Z","7.8.2":"2022-04-30T02:44:20.634Z","7.9.0":"2022-04-30T04:50:16.143Z","7.9.1":"2022-05-11T19:27:53.310Z","7.10.0":"2022-05-11T19:32:02.584Z","7.10.1":"2022-05-11T22:51:48.451Z","7.10.2":"2022-06-23T22:30:48.426Z","7.10.3":"2022-06-29T19:19:17.650Z","7.11.0":"2022-06-29T22:07:11.851Z","7.12.0":"2022-06-29T22:42:39.511Z","7.12.1":"2022-07-12T23:00:45.304Z","7.13.0":"2022-07-12T23:16:44.308Z","7.13.1":"2022-07-14T23:30:07.377Z","7.13.2":"2022-08-02T17:57:32.835Z","7.14.0":"2022-08-16T22:14:17.758Z"},"users":{"285858315":true,"fgribreau":true,"romac":true,"zaphod1984":true,"brianloveswords":true,"cybo42":true,"jacques":true,"luislobo":true,"soloi":true,"wookieb":true,"lianall":true,"piron_t":true,"zihuxinyu":true,"bchociej":true,"mpinteractiv":true,"voxpelli":true,"ashleybrener":true,"jianping":true,"hoitmort":true,"dgarlitt":true,"hden":true,"zhangyaochun":true,"yvesm":true,"acjohnso25":true,"adamlu":true,"qt911025":true,"kenlimmj":true,"ashsidhu":true,"ccyll":true,"genexp":true,"sessionbean":true,"minghe":true,"micahjonas":true,"patmcc":true,"michaelnisi":true,"syzer":true,"barenko":true,"hckhanh":true,"draganhr":true,"crazyjingling":true,"lfeng":true,"brunocalou":true,"andrew.medvedev":true,"bapinney":true,"thinkholic":true,"shavyg2":true,"makay":true,"buzuli":true,"mccoyjordan":true,"derekclair":true,"vasz":true,"sirany":true,"coalesce":true,"shan":true,"hugojosefson":true,"newswim":true,"princetoad":true,"chriszs":true,"belirafon":true,"detj":true,"wangnan0610":true,"dskrepps":true,"lcdss":true,"sopov":true,"jovinbm":true,"jerrywu":true,"koslun":true,"endless":true,"cestrensem":true,"v3rron":true,"neo1":true,"mojaray2k":true,"sisidovski":true,"egantz":true,"shangsinian":true,"nickleefly":true,"appsparkler":true,"tommytroylin":true,"joaquin.briceno":true,"joris-van-der-wel":true,"nikolayantonovsoserov":true,"leonzhao":true,"nuer":true,"ahmedelgabri":true,"roccomuso":true,"wangfeia":true,"adamantium169":true,"tsxuehu":true,"gavinning":true,"yinyongcom666":true,"shaomingquan":true,"ahmed-dinar":true,"xinwangwang":true,"ssljivic":true,"tedyhy":true,"tayden":true,"subinvarghesein":true,"gindis":true,"d-band":true,"sasquatch":true,"yeming":true,"joanmi":true,"kktam":true,"tiancheng9":true,"comigo-npmjs":true,"fargie_s":true,"vparaskevas":true,"hanhq":true,"neefrankie":true,"heineiuo":true,"cr8tiv":true,"biao166":true,"chaoliu":true,"ksugiura":true,"elcobvg":true,"diegorbaquero":true,"soenkekluth":true,"x-cold":true,"isayme":true,"dwqs":true,"zuojiang":true,"daizch":true},"readme":"# lru-cache\n\nA cache object that deletes the least-recently-used items.\n\nSpecify a max number of the most recently used items that you\nwant to keep, and this cache will keep that many of the most\nrecently accessed items.\n\nThis is not primarily a TTL cache, and does not make strong TTL\nguarantees.  There is no preemptive pruning of expired items by\ndefault, but you _may_ set a TTL on the cache or on a single\n`set`.  If you do so, it will treat expired items as missing, and\ndelete them when fetched.  If you are more interested in TTL\ncaching than LRU caching, check out\n[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).\n\nAs of version 7, this is one of the most performant LRU\nimplementations available in JavaScript, and supports a wide\ndiversity of use cases.  However, note that using some of the\nfeatures will necessarily impact performance, by causing the\ncache to have to do more work.  See the \"Performance\" section\nbelow.\n\n## Installation\n\n```bash\nnpm install lru-cache --save\n```\n\n## Usage\n\n```js\nconst LRU = require('lru-cache')\n\n// At least one of 'max', 'ttl', or 'maxSize' is required, to prevent\n// unsafe unbounded storage.\n//\n// In most cases, it's best to specify a max for performance, so all\n// the required memory allocation is done up-front.\n//\n// All the other options are optional, see the sections below for\n// documentation on what each one does.  Most of them can be\n// overridden for specific items in get()/set()\nconst options = {\n  max: 500,\n\n  // for use with tracking overall storage size\n  maxSize: 5000,\n  sizeCalculation: (value, key) => {\n    return 1\n  },\n\n  // for use when you need to clean up something when objects\n  // are evicted from the cache\n  dispose: (value, key) => {\n    freeFromMemoryOrWhatever(value)\n  },\n\n  // how long to live in ms\n  ttl: 1000 * 60 * 5,\n\n  // return stale items before removing from cache?\n  allowStale: false,\n\n  updateAgeOnGet: false,\n  updateAgeOnHas: false,\n\n  // async method to use for cache.fetch(), for\n  // stale-while-revalidate type of behavior\n  fetchMethod: async (key, staleValue, { options, signal }) => {}\n}\n\nconst cache = new LRU(options)\n\ncache.set(\"key\", \"value\")\ncache.get(\"key\") // \"value\"\n\n// non-string keys ARE fully supported\n// but note that it must be THE SAME object, not\n// just a JSON-equivalent object.\nvar someObject = { a: 1 }\ncache.set(someObject, 'a value')\n// Object keys are not toString()-ed\ncache.set('[object Object]', 'a different value')\nassert.equal(cache.get(someObject), 'a value')\n// A similar object with same keys/values won't work,\n// because it's a different object identity\nassert.equal(cache.get({ a: 1 }), undefined)\n\ncache.clear()    // empty the cache\n```\n\nIf you put more stuff in it, then items will fall out.\n\n## Options\n\n### `max`\n\nThe maximum number (or size) of items that remain in the cache\n(assuming no TTL pruning or explicit deletions).  Note that fewer\nitems may be stored if size calculation is used, and `maxSize` is\nexceeded.  This must be a positive finite intger.\n\nAt least one of `max`, `maxSize`, or `TTL` is required.  This\nmust be a positive integer if set.\n\n**It is strongly recommended to set a `max` to prevent unbounded\ngrowth of the cache.**  See \"Storage Bounds Safety\" below.\n\n### `maxSize`\n\nSet to a positive integer to track the sizes of items added to\nthe cache, and automatically evict items in order to stay below\nthis size.  Note that this may result in fewer than `max` items\nbeing stored.\n\nAttempting to add an item to the cache whose calculated size is\ngreater that this amount will be a no-op.  The item will not be\ncached, and no other items will be evicted.\n\nOptional, must be a positive integer if provided.\n\nSets `maxItemSize` to the same value, unless a different value is\nprovided for `maxItemSize`.\n\nAt least one of `max`, `maxSize`, or `TTL` is required.  This\nmust be a positive integer if set.\n\nEven if size tracking is enabled, **it is strongly recommended to\nset a `max` to prevent unbounded growth of the cache.**  See\n\"Storage Bounds Safety\" below.\n\n### `maxEntrySize`\n\nSet to a positive integer to track the sizes of items added to\nthe cache, and prevent caching any item over a given size.\nAttempting to add an item whose calculated size is greater than\nthis amount will be a no-op.  The item will not be cached, and no\nother items will be evicted.\n\nOptional, must be a positive integer if provided.  Defaults to\nthe value of `maxSize` if provided.\n\n### `sizeCalculation`\n\nFunction used to calculate the size of stored items.  If you're\nstoring strings or buffers, then you probably want to do\nsomething like `n => n.length`.  The item is passed as the first\nargument, and the key is passed as the second argument.\n\nThis may be overridden by passing an options object to\n`cache.set()`.\n\nRequires `maxSize` to be set.  If the resulting calculated size\nis greater than `maxSize`, then the item will not be added to the\ncache.\n\nDeprecated alias: `length`\n\n### `fetchMethod`\n\nFunction that is used to make background asynchronous fetches.\nCalled with `fetchMethod(key, staleValue, { signal, options,\ncontext })`. May return a Promise.\n\nIf `fetchMethod` is not provided, then `cache.fetch(key)` is\nequivalent to `Promise.resolve(cache.get(key))`.\n\nThe `signal` object is an `AbortSignal` if that's available in\nthe global object, otherwise it's a pretty close polyfill.\n\nIf at any time, `signal.aborted` is set to `true`, or if the\n`signal.onabort` method is called, or if it emits an `'abort'`\nevent which you can listen to with `addEventListener`, then that\nmeans that the fetch should be abandoned.  This may be passed\nalong to async functions aware of AbortController/AbortSignal\nbehavior.\n\nThe `options` object is a union of the options that may be\nprovided to `set()` and `get()`.  If they are modified, then that\nwill result in modifying the settings to `cache.set()` when the\nvalue is resolved.  For example, a DNS cache may update the TTL\nbased on the value returned from a remote DNS server by changing\n`options.ttl` in the `fetchMethod`.\n\n### `fetchContext`\n\nArbitrary data that can be passed to the `fetchMethod` as the\n`context` option.\n\nNote that this will only be relevant when the `cache.fetch()`\ncall needs to call `fetchMethod()`.  Thus, any data which will\nmeaningfully vary the fetch response needs to be present in the\nkey.  This is primarily intended for including `x-request-id`\nheaders and the like for debugging purposes, which do not affect\nthe `fetchMethod()` response.\n\n### `noDeleteOnFetchRejection`\n\nIf a `fetchMethod` throws an error or returns a rejected promise,\nthen by default, any existing stale value will be removed from\nthe cache.\n\nIf `noDeleteOnFetchRejection` is set to `true`, then this\nbehavior is suppressed, and the stale value remains in the cache\nin the case of a rejected `fetchMethod`.\n\nThis is important in cases where a `fetchMethod` is _only_ called\nas a background update while the stale value is returned, when\n`allowStale` is used.\n\nThis may be set in calls to `fetch()`, or defaulted on the\nconstructor.\n\n### `dispose`\n\nFunction that is called on items when they are dropped from the\ncache, as `this.dispose(value, key, reason)`.\n\nThis can be handy if you want to close file descriptors or do\nother cleanup tasks when items are no longer stored in the cache.\n\n**NOTE**: It is called *before* the item has been fully removed\nfrom the cache, so if you want to put it right back in, you need\nto wait until the next tick.  If you try to add it back in during\nthe `dispose()` function call, it will break things in subtle and\nweird ways.\n\nUnlike several other options, this may _not_ be overridden by\npassing an option to `set()`, for performance reasons.  If\ndisposal functions may vary between cache entries, then the\nentire list must be scanned on every cache swap, even if no\ndisposal function is in use.\n\nThe `reason` will be one of the following strings, corresponding\nto the reason for the item's deletion:\n\n* `evict` Item was evicted to make space for a new addition\n* `set` Item was overwritten by a new value\n* `delete` Item was removed by explicit `cache.delete(key)` or by\n  calling `cache.clear()`, which deletes everything.\n\nThe `dispose()` method is _not_ called for canceled calls to\n`fetchMethod()`.  If you wish to handle evictions, overwrites,\nand deletes of in-flight asynchronous fetches, you must use the\n`AbortSignal` provided.\n\nOptional, must be a function.\n\n### `disposeAfter`\n\nThe same as `dispose`, but called _after_ the entry is completely\nremoved and the cache is once again in a clean state.\n\nIt is safe to add an item right back into the cache at this\npoint.  However, note that it is _very_ easy to inadvertently\ncreate infinite recursion in this way.\n\nThe `disposeAfter()` method is _not_ called for canceled calls to\n`fetchMethod()`.  If you wish to handle evictions, overwrites,\nand deletes of in-flight asynchronous fetches, you must use the\n`AbortSignal` provided.\n\n### `noDisposeOnSet`\n\nSet to `true` to suppress calling the `dispose()` function if the\nentry key is still accessible within the cache.\n\nThis may be overridden by passing an options object to\n`cache.set()`.\n\nBoolean, default `false`.  Only relevant if `dispose` or\n`disposeAfter` options are set.\n\n### `ttl`\n\nMax time to live for items before they are considered stale.\nNote that stale items are NOT preemptively removed by default,\nand MAY live in the cache, contributing to its LRU max, long\nafter they have expired.\n\nAlso, as this cache is optimized for LRU/MRU operations, some of\nthe staleness/TTL checks will reduce performance, as they will\nincur overhead by deleting from Map objects rather than simply\nthrowing old Map objects away.\n\nThis is not primarily a TTL cache, and does not make strong TTL\nguarantees.  There is no pre-emptive pruning of expired items,\nbut you _may_ set a TTL on the cache, and it will treat expired\nitems as missing when they are fetched, and delete them.\n\nOptional, but must be a positive integer in ms if specified.\n\nThis may be overridden by passing an options object to\n`cache.set()`.\n\nAt least one of `max`, `maxSize`, or `TTL` is required.  This\nmust be a positive integer if set.\n\nEven if ttl tracking is enabled, **it is strongly recommended to\nset a `max` to prevent unbounded growth of the cache.**  See\n\"Storage Bounds Safety\" below.\n\nIf ttl tracking is enabled, and `max` and `maxSize` are not set,\nand `ttlAutopurge` is not set, then a warning will be emitted\ncautioning about the potential for unbounded memory consumption.\n\nDeprecated alias: `maxAge`\n\n### `noUpdateTTL`\n\nBoolean flag to tell the cache to not update the TTL when setting\na new value for an existing key (ie, when updating a value rather\nthan inserting a new value).  Note that the TTL value is _always_\nset (if provided) when adding a new entry into the cache.\n\nThis may be passed as an option to `cache.set()`.\n\nBoolean, default false.\n\n### `ttlResolution`\n\nMinimum amount of time in ms in which to check for staleness.\nDefaults to `1`, which means that the current time is checked at\nmost once per millisecond.\n\nSet to `0` to check the current time every time staleness is\ntested.\n\nNote that setting this to a higher value _will_ improve\nperformance somewhat while using ttl tracking, albeit at the\nexpense of keeping stale items around a bit longer than intended.\n\n### `ttlAutopurge`\n\nPreemptively remove stale items from the cache.\n\nNote that this may _significantly_ degrade performance,\nespecially if the cache is storing a large number of items.  It\nis almost always best to just leave the stale items in the cache,\nand let them fall out as new items are added.\n\nNote that this means that `allowStale` is a bit pointless, as\nstale items will be deleted almost as soon as they expire.\n\nUse with caution!\n\nBoolean, default `false`\n\n### `allowStale`\n\nBy default, if you set `ttl`, it'll only delete stale items from\nthe cache when you `get(key)`.  That is, it's not preemptively\npruning items.\n\nIf you set `allowStale:true`, it'll return the stale value as\nwell as deleting it.  If you don't set this, then it'll return\n`undefined` when you try to get a stale entry.\n\nNote that when a stale entry is fetched, _even if it is returned\ndue to `allowStale` being set_, it is removed from the cache\nimmediately.  You can immediately put it back in the cache if you\nwish, thus resetting the TTL.\n\nThis may be overridden by passing an options object to\n`cache.get()`.  The `cache.has()` method will always return\n`false` for stale items.\n\nBoolean, default false, only relevant if `ttl` is set.\n\nDeprecated alias: `stale`\n\n### `noDeleteOnStaleGet`\n\nWhen using time-expiring entries with `ttl`, by default stale\nitems will be removed from the cache when the key is accessed\nwith `cache.get()`.\n\nSetting `noDeleteOnStaleGet` to `true` will cause stale items to\nremain in the cache, until they are explicitly deleted with\n`cache.delete(key)`, or retrieved with `noDeleteOnStaleGet` set\nto `false`.\n\nThis may be overridden by passing an options object to\n`cache.get()`.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n### `updateAgeOnGet`\n\nWhen using time-expiring entries with `ttl`, setting this to\n`true` will make each item's age reset to 0 whenever it is\nretrieved from cache with `get()`, causing it to not expire.  (It\ncan still fall out of cache based on recency of use, of course.)\n\nThis may be overridden by passing an options object to\n`cache.get()`.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n### `updateAgeOnHas`\n\nWhen using time-expiring entries with `ttl`, setting this to\n`true` will make each item's age reset to 0 whenever its presence\nin the cache is checked with `has()`, causing it to not expire.\n(It can still fall out of cache based on recency of use, of\ncourse.)\n\nThis may be overridden by passing an options object to\n`cache.has()`.\n\nBoolean, default false, only relevant if `ttl` is set.\n\n## API\n\n### `new LRUCache(options)`\n\nCreate a new LRUCache.  All options are documented above, and are\non the cache as public members.\n\n### `cache.max`, `cache.maxSize`, `cache.allowStale`,\n`cache.noDisposeOnSet`, `cache.sizeCalculation`, `cache.dispose`,\n`cache.maxSize`, `cache.ttl`, `cache.updateAgeOnGet`,\n`cache.updateAgeOnHas`\n\nAll option names are exposed as public members on the cache\nobject.\n\nThese are intended for read access only.  Changing them during\nprogram operation can cause undefined behavior.\n\n### `cache.size`\n\nThe total number of items held in the cache at the current\nmoment.\n\n### `cache.calculatedSize`\n\nThe total size of items in cache when using size tracking.\n\n### `set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet, start }])`\n\nAdd a value to the cache.\n\nOptional options object may contain `ttl` and `sizeCalculation`\nas described above, which default to the settings on the cache\nobject.\n\nIf `start` is provided, then that will set the effective start\ntime for the TTL calculation.  Note that this must be a previous\nvalue of `performance.now()` if supported, or a previous value of\n`Date.now()` if not.\n\nOptions object my also include `size`, which will prevent calling\nthe `sizeCalculation` function and just use the specified number\nif it is a positive integer, and `noDisposeOnSet` which will\nprevent calling a `dispose` function in the case of overwrites.\n\nIf the `size` (or return value of `sizeCalculation`) is greater\nthan `maxSize`, then the item will not be added to the cache.\n\nWill update the recency of the entry.\n\nReturns the cache object.\n\n### `get(key, { updateAgeOnGet, allowStale } = {}) => value`\n\nReturn a value from the cache.\n\nWill update the recency of the cache entry found.\n\nIf the key is not found, `get()` will return `undefined`.  This\ncan be confusing when setting values specifically to `undefined`,\nas in `cache.set(key, undefined)`.  Use `cache.has()` to\ndetermine whether a key is present in the cache at all.\n\n### `async fetch(key, { updateAgeOnGet, allowStale, size,\nsizeCalculation, ttl, noDisposeOnSet, forceRefresh } = {}) => Promise`\n\nIf the value is in the cache and not stale, then the returned\nPromise resolves to the value.\n\nIf not in the cache, or beyond its TTL staleness, then\n`fetchMethod(key, staleValue, options)` is called, and the value\nreturned will be added to the cache once resolved.\n\nIf called with `allowStale`, and an asynchronous fetch is\ncurrently in progress to reload a stale value, then the former\nstale value will be returned.\n\nIf called with `forceRefresh`, then the cached item will be\nre-fetched, even if it is not stale.  However, if `allowStale` is\nset, then the old value will still be returned.  This is useful\nin cases where you want to force a reload of a cached value.  If\na background fetch is already in progress, then `forceRefresh`\nhas no effect.\n\nMultiple fetches for the same `key` will only call `fetchMethod`\na single time, and all will be resolved when the value is\nresolved, even if different options are used.\n\nIf `fetchMethod` is not specified, then this is effectively an\nalias for `Promise.resolve(cache.get(key))`.\n\nWhen the fetch method resolves to a value, if the fetch has not\nbeen aborted due to deletion, eviction, or being overwritten,\nthen it is added to the cache using the options provided.\n\n### `peek(key, { allowStale } = {}) => value`\n\nLike `get()` but doesn't update recency or delete stale items.\n\nReturns `undefined` if the item is stale, unless `allowStale` is\nset either on the cache or in the options object.\n\n### `has(key, { updateAgeOnHas } = {}) => Boolean`\n\nCheck if a key is in the cache, without updating the recency of\nuse.  Age is updated if `updateAgeOnHas` is set to `true` in\neither the options or the constructor.\n\nWill return `false` if the item is stale, even though it is\ntechnically in the cache.\n\n### `delete(key)`\n\nDeletes a key out of the cache.\n\nReturns `true` if the key was deleted, `false` otherwise.\n\n### `clear()`\n\nClear the cache entirely, throwing away all values.\n\nDeprecated alias: `reset()`\n\n### `keys()`\n\nReturn a generator yielding the keys in the cache, in order from\nmost recently used to least recently used.\n\n### `rkeys()`\n\nReturn a generator yielding the keys in the cache, in order from\nleast recently used to most recently used.\n\n### `values()`\n\nReturn a generator yielding the values in the cache, in order\nfrom most recently used to least recently used.\n\n### `rvalues()`\n\nReturn a generator yielding the values in the cache, in order\nfrom least recently used to most recently used.\n\n### `entries()`\n\nReturn a generator yielding `[key, value]` pairs, in order from\nmost recently used to least recently used.\n\n### `rentries()`\n\nReturn a generator yielding `[key, value]` pairs, in order from\nleast recently used to most recently used.\n\n### `find(fn, [getOptions])`\n\nFind a value for which the supplied `fn` method returns a truthy\nvalue, similar to `Array.find()`.\n\n`fn` is called as `fn(value, key, cache)`.\n\nThe optional `getOptions` are applied to the resulting `get()` of\nthe item found.\n\n### `dump()`\n\nReturn an array of `[key, entry]` objects which can be passed to\n`cache.load()`\n\nThe `start` fields are calculated relative to a portable\n`Date.now()` timestamp, even if `performance.now()` is available.\n\nStale entries are always included in the `dump`, even if\n`allowStale` is false.\n\nNote: this returns an actual array, not a generator, so it can be\nmore easily passed around.\n\n### `load(entries)`\n\nReset the cache and load in the items in `entries` in the order\nlisted.  Note that the shape of the resulting cache may be\ndifferent if the same options are not used in both caches.\n\nThe `start` fields are assumed to be calculated relative to a\nportable `Date.now()` timestamp, even if `performance.now()` is\navailable.\n\n### `purgeStale()`\n\nDelete any stale entries.  Returns `true` if anything was\nremoved, `false` otherwise.\n\nDeprecated alias: `prune`\n\n### `getRemainingTTL(key)`\n\nReturn the number of ms left in the item's TTL.  If item is not\nin cache, returns `0`.  Returns `Infinity` if item is in cache\nwithout a defined TTL.\n\n### `forEach(fn, [thisp])`\n\nCall the `fn` function with each set of `fn(value, key, cache)`\nin the LRU cache, from most recent to least recently used.\n\nDoes not affect recency of use.\n\nIf `thisp` is provided, function will be called in the\n`this`-context of the provided object.\n\n### `rforEach(fn, [thisp])`\n\nSame as `cache.forEach(fn, thisp)`, but in order from least\nrecently used to most recently used.\n\n### `pop()`\n\nEvict the least recently used item, returning its value.\n\nReturns `undefined` if cache is empty.\n\n### Internal Methods and Properties\n\nIn order to optimize performance as much as possible, \"private\"\nmembers and methods are exposed on the object as normal\nproperties, rather than being accessed via Symbols, private\nmembers, or closure variables.\n\n**Do not use or rely on these.**  They will change or be removed\nwithout notice.  They will cause undefined behavior if used\ninappropriately.  There is no need or reason to ever call them\ndirectly.\n\nThis documentation is here so that it is especially clear that\nthis not \"undocumented\" because someone forgot; it _is_\ndocumented, and the documentation is telling you not to do it.\n\n**Do not report bugs that stem from using these properties.**\nThey will be ignored.\n\n* `initializeTTLTracking()` Set up the cache for tracking TTLs\n* `updateItemAge(index)` Called when an item age is updated, by\n  internal ID\n* `setItemTTL(index)` Called when an item ttl is updated, by\n  internal ID\n* `isStale(index)` Called to check an item's staleness, by\n  internal ID\n* `initializeSizeTracking()` Set up the cache for tracking item\n  size.  Called automatically when a size is specified.\n* `removeItemSize(index)` Updates the internal size calculation\n  when an item is removed or modified, by internal ID\n* `addItemSize(index)` Updates the internal size calculation when\n  an item is added or modified, by internal ID\n* `indexes()` An iterator over the non-stale internal IDs, from\n  most recently to least recently used.\n* `rindexes()` An iterator over the non-stale internal IDs, from\n  least recently to most recently used.\n* `newIndex()` Create a new internal ID, either reusing a deleted\n  ID, evicting the least recently used ID, or walking to the end\n  of the allotted space.\n* `evict()` Evict the least recently used internal ID, returning\n  its ID.  Does not do any bounds checking.\n* `connect(p, n)` Connect the `p` and `n` internal IDs in the\n  linked list.\n* `moveToTail(index)` Move the specified internal ID to the most\n  recently used position.\n* `keyMap` Map of keys to internal IDs\n* `keyList` List of keys by internal ID\n* `valList` List of values by internal ID\n* `sizes` List of calculated sizes by internal ID\n* `ttls` List of TTL values by internal ID\n* `starts` List of start time values by internal ID\n* `next` Array of \"next\" pointers by internal ID\n* `prev` Array of \"previous\" pointers by internal ID\n* `head` Internal ID of least recently used item\n* `tail` Internal ID of most recently used item\n* `free` Stack of deleted internal IDs\n\n## Storage Bounds Safety\n\nThis implementation aims to be as flexible as possible, within\nthe limits of safe memory consumption and optimal performance.\n\nAt initial object creation, storage is allocated for `max` items.\nIf `max` is set to zero, then some performance is lost, and item\ncount is unbounded.  Either `maxSize` or `ttl` _must_ be set if\n`max` is not specified.\n\nIf `maxSize` is set, then this creates a safe limit on the\nmaximum storage consumed, but without the performance benefits of\npre-allocation.  When `maxSize` is set, every item _must_ provide\na size, either via the `sizeCalculation` method provided to the\nconstructor, or via a `size` or `sizeCalculation` option provided\nto `cache.set()`.  The size of every item _must_ be a positive\ninteger.\n\nIf neither `max` nor `maxSize` are set, then `ttl` tracking must\nbe enabled.  Note that, even when tracking item `ttl`, items are\n_not_ preemptively deleted when they become stale, unless\n`ttlAutopurge` is enabled.  Instead, they are only purged the\nnext time the key is requested.  Thus, if `ttlAutopurge`, `max`,\nand `maxSize` are all not set, then the cache will potentially\ngrow unbounded.\n\nIn this case, a warning is printed to standard error.  Future\nversions may require the use of `ttlAutopurge` if `max` and\n`maxSize` are not specified.\n\nIf you truly wish to use a cache that is bound _only_ by TTL\nexpiration, consider using a `Map` object, and calling\n`setTimeout` to delete entries when they expire.  It will perform\nmuch better than an LRU cache.\n\nHere is an implementation you may use, under the same\n[license](./LICENSE) as this package:\n\n```js\n// a storage-unbounded ttl cache that is not an lru-cache\nconst cache = {\n  data: new Map(),\n  timers: new Map(),\n  set: (k, v, ttl) => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.set(k, setTimeout(() => cache.del(k), ttl))\n    cache.data.set(k, v)\n  },\n  get: k => cache.data.get(k),\n  has: k => cache.data.has(k),\n  delete: k => {\n    if (cache.timers.has(k)) {\n      clearTimeout(cache.timers.get(k))\n    }\n    cache.timers.delete(k)\n    return cache.data.delete(k)\n  },\n  clear: () => {\n    cache.data.clear()\n    for (const v of cache.timers.values()) {\n      clearTimeout(v)\n    }\n    cache.timers.clear()\n  }\n}\n```\n\nIf that isn't to your liking, check out\n[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).\n\n## Performance\n\nAs of January 2022, version 7 of this library is one of the most\nperformant LRU cache implementations in JavaScript.\n\nBenchmarks can be extremely difficult to get right.  In\nparticular, the performance of set/get/delete operations on\nobjects will vary _wildly_ depending on the type of key used.  V8\nis highly optimized for objects with keys that are short strings,\nespecially integer numeric strings.  Thus any benchmark which\ntests _solely_ using numbers as keys will tend to find that an\nobject-based approach performs the best.\n\nNote that coercing _anything_ to strings to use as object keys is\nunsafe, unless you can be 100% certain that no other type of\nvalue will be used.  For example:\n\n```js\nconst myCache = {}\nconst set = (k, v) => myCache[k] = v\nconst get = (k) => myCache[k]\n\nset({}, 'please hang onto this for me')\nset('[object Object]', 'oopsie')\n```\n\nAlso beware of \"Just So\" stories regarding performance.  Garbage\ncollection of large (especially: deep) object graphs can be\nincredibly costly, with several \"tipping points\" where it\nincreases exponentially.  As a result, putting that off until\nlater can make it much worse, and less predictable.  If a library\nperforms well, but only in a scenario where the object graph is\nkept shallow, then that won't help you if you are using large\nobjects as keys.\n\nIn general, when attempting to use a library to improve\nperformance (such as a cache like this one), it's best to choose\nan option that will perform well in the sorts of scenarios where\nyou'll actually use it.\n\nThis library is optimized for repeated gets and minimizing\neviction time, since that is the expected need of a LRU.  Set\noperations are somewhat slower on average than a few other\noptions, in part because of that optimization.  It is assumed\nthat you'll be caching some costly operation, ideally as rarely\nas possible, so optimizing set over get would be unwise.\n\nIf performance matters to you:\n\n1. If it's at all possible to use small integer values as keys,\n   and you can guarantee that no other types of values will be\n   used as keys, then do that, and use a cache such as\n   [lru-fast](https://npmjs.com/package/lru-fast), or\n   [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache)\n   which uses an Object as its data store.\n2. Failing that, if at all possible, use short non-numeric\n   strings (ie, less than 256 characters) as your keys, and use\n   [mnemonist's\n   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).\n3. If the types of your keys will be long strings, strings that\n   look like floats, `null`, objects, or some mix of types, or if\n   you aren't sure, then this library will work well for you.\n4. Do not use a `dispose` function, size tracking, or especially\n   ttl behavior, unless absolutely needed.  These features are\n   convenient, and necessary in some use cases, and every attempt\n   has been made to make the performance impact minimal, but it\n   isn't nothing.\n\n## Breaking Changes in Version 7\n\nThis library changed to a different algorithm and internal data\nstructure in version 7, yielding significantly better\nperformance, albeit with some subtle changes as a result.\n\nIf you were relying on the internals of LRUCache in version 6 or\nbefore, it probably will not work in version 7 and above.\n\nFor more info, see the [change log](CHANGELOG.md).\n","readmeFilename":"README.md","homepage":"https://github.com/isaacs/node-lru-cache#readme","bugs":{"url":"https://github.com/isaacs/node-lru-cache/issues"},"license":"ISC","keywords":["mru","lru","cache"],"_etag":"W/\"d1f31b3901c484f47c9c0a820282b9a9\"","_lastModified":"Tue, 16 Aug 2022 22:14:19 GMT"}